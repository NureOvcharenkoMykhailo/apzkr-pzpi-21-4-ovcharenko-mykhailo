Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії


КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизації процесів створення дієт


Студент гр. ПЗПІ-21-4			___________ Овчаренко М.О.
						        (підпис)
Керівник роботи 				___________ доц. Лещинський В.О.
						        (підпис)
						Роботу захищено «__»_________2024 р.
						з оцінкою _________________________
Комісія: 					___________________ доц. Лещинський В.О.
						___________________ доц. Лещинська І.О.
						___________________ ст.викл. Сокорчук І.П.



Харків
2024 р.
АРКУШ ЗАВДАННЯ

Харківський національний університет радіоелектроніки
Факультет        комп’ютерних наук          Кафедра          програмної інженерії           
Спеціальність                      121 – Інженерія програмного забезпечення                      
Курс                            3                                Семестр                       6                               
Навчальна дисципліна            Архітектура програмного забезпечення                       

ЗАВДАННЯ 
НА ЛАБОРАТОРНІ РОБОТИ СТУДЕНТОВІ
                                           Овчаренко Михайло Олексійовичу                                      
1. Тема проєкту: Програмна система для автоматизації процесів створення дієт «Healfood».
2. Термін узгодження завдання з лабораторних робіт:  «31»   березня     2024 р.
3. Термін здачі завдання з лабораторних робіт:  «10»   червня     2024 р.
4. Вихідні дані до проєкту: Українська та англійська мови для інтерфейсу, програмна система, яка складається з наступних компонентів: серверна частина (backend), клієнтська частина (frontend), мобільний програмний застосунок, програмний застосунок для IoT або Smart Device, інтегровані інструменти адміністрування системи (управління користувачами системи, управління даними системи, створення резервних копій налаштувань та даних, експорт та імпорт даних, налаштувань, управління сертифікатами). Також система включає інтернаціоналізацію та локалізацію, що охоплює кодові таблиці символів, обчислення та формат дати та часу, місцевий та універсальний час, метричні одиниці вимірювання, англійську та американську системи мір, порядок сортування текстових значень та напрям введення тексту.
5. Зміст звітів з лабораторних робіт: У процесі розробки проєкту спершу розглядається опис Vision & Scope, а потім йдуть описи прийнятих інженерних рішень для серверної частини, специфікації REST, методів обробки даних та програмного коду серверної частини; описи інженерних рішень IoT частини, програмного коду IoT частини, описи інженерних рішень клієнтської частини, програмного коду клієнтської частини, описи інженерних рішень мобільного застосунку та програмного коду мобільного застосунку.
6. Перелік графічного матеріалу: Серверна частина містить UML діаграму розгортання, UML діаграму прецедентів та ER-модель даних; IoT частина має UML діаграму прецедентів, UML діаграму взаємодії, UML діаграму діяльності; клієнтська частина включає UML діаграму прецедентів та UML діаграму компонентів; мобільна частина включає UML діаграму прецедентів та UML діаграму компонентів.

КАЛЕНДАРНИЙ ПЛАН
№
Назва етапів курсової роботи
Термін виконання
етапів роботи
Примітка
1
Функціональна специфікація програмного проєкту
22.02.2024
Виконано
2
Проєктування програмного проєкту
01.03.2024
Виконано
3
Кодування програмного проєкту
01.04.2024
Виконано
4
Оформлення пояснювальної записки
30.05.2024
Виконано
5
Захист курсової роботи
08.06.2024
Виконано

Дата видачі теми проєкту:  «31»   березня  2024 р.
Викладач лабораторних робіт                   доц. Лещинська І. О.
                                                       (підпис)
Завдання прийняв до виконання ст. гр. ПЗПІ-21-4                   Овчаренко М. О.
                                                                                         (підпис)

РЕФЕРАТ


Пояснювальна записка до курсової роботи: 92 с., 21 рис., 2 табл., 4 додатки, 6 джерел.
АВТОРИЗАЦІЯ, АНАЛІЗ ДАНИХ, БАЗА ДАНИХ, БЕЗПЕКА ДАНИХ, ДІЄТА, ЖИРОВИЙ ПРОШАРОК, КОНСОЛЬНИЙ ДОДАТОК, КОРИСТУВАЧ, КРОВ'ЯНИЙ ТИСК, МОНІТОРИНГ, ПОКАЗНИКИ ЗДОРОВ’Я, РЕАЛЬНИЙ ЧАС, РІВЕНЬ КИСНЮ, СЕРЦЕБИТТЯ, СИСТЕМА СПОСТЕРЕЖЕННЯ СПОВІЩЕННЯ.

Об'єктом дослідження є індустрія управління дієтами, актуальною проблемою є кількість ручної роботи, яку доводиться виконувати кожному, хто намагається сісти на дієту.
Метою курсової роботи є створення системи, яка буде автоматично відстежувати та оновлювати раціон користувача на основі його життєвих показників в режимі реального часу.
Програмний застосунок розроблено мовою програмування Python, сервер бази даних на основі PostgreSQL, веб-додаток розроблено мовою програмування TypeScript з використанням технології Vite, IoT-пристрій розроблено на мові C у вигляді консольного застосунку.
Програмна система для автоматизації процесів створення дієт в результаті була розроблена та складається з сервера, веб-застосунку та смарт-пристрою.
ЗМІСТ

Реферат	4
Зміст	5
Вступ	7
1 Аналіз предметної області	8
1.1 Бізнес-вимоги	8
1.1.1 Бізнес-можливості	8
1.1.2 Бізнес-цілі та критерії успіху	9
1.1.3 Потреби клієнтів або ринку	10
1.1.3.1 Потреби звичайних користувачів:	10
1.1.3.2 Потреби модераторів:	11
1.1.3.3 Потреби адміністраторів:	11
1.1.4 Бізнес-ризики	11
1.1.4.1 Ризики:	11
1.1.4.2 Можливі рішення:	12
1.2 Концепція рішення	12
1.2.1 Окреслення концепції	12
1.2.2 Головна функціональність	13
1.2.3 Припущення та залежності	14
1.3 Рамки та обмеження проєкту	15
1.3.1 Рамки первинного випуску	15
1.3.2 Рамки наступних випусків	17
1.3.3 Обмеження та винятки	18
1.4 Бізнес-контекст	19
1.4.1 Профілі зацікавлених сторін	19
1.4.2 Пріоритети проєкту	20
1.4.3 Робоче середовище	20
2 Постановка задачі	22
3 Проєктування бази даних	23
4 Архітектура програмної системи	25
4.1 Архітектура серверної частини	25
4.2 Архітектура серверної частини	28
4.3 Архітектура клієнтської частини	33
5 Опис програмної системи	37
Висновки	44
Перелік джерел посилання	45
Додаток А	46
Додаток Б	47
Додаток В	72
Додаток Г	76

ВСТУП


У сучасному світі, коли люди все більше звертають увагу на здорове харчування та правильний режим харчування, проблема створення та управління дієтами стає актуальною та важливою. Існують деякі платформи для створення дієт, але їхній функціонал і зручність використання часто не відповідають сучасним вимогам.
Програмна система буде надавати користувачам можливість з легкістю створювати, порівнювати та управляти різноманітними дієтами відповідно до їхніх потреб та уподобань. Передбачається високий рівень зручності та функціональності, який буде сприяти покращенню харчувальних звичок користувачів.
Мета програмної системи полягає в створенні простору, де користувачі можуть з легкістю створювати та управляти різними дієтами – від дієт для схуднення та збереження ваги до дієт для покращення здоров'я та відчуття добробуту. Проєкт покликаний полегшити процес створення та управління дієтами, забезпечуючи користувачам великий вибір, інформативність та ефективність у використанні.
З урахуванням потенційних ризиків та обмежень, система буде розроблена з урахуванням найвищих стандартів безпеки та точності, щоб забезпечити користувачів надійним та ефективним інструментом для створення та управління дієтами.
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес-можливості

У конкурентному середовищі систем онлайн-бронювання дозвілля стикаємося з двома основними продуктами-конкурентами: EatThisMuch, MyFitnessPal, Lifesum та Prospre.
EatThisMuch – це платформа, яка створює персоналізовані плани харчування. Можливо, найкращий конкурент, проте вона не має можливості додавати власні продукти, підтримується лише в США. Вона вимагає багато ручного введення даних від користувача і не має мобільного додатку.
Prospre – це платформа для створення планів харчування. Вона використовує мобільний додаток, проте підтримує лише США, показує багато інформації про їжу, але не в легкій для розуміння формі. Також не підтримує додавання власних продуктів і вимагає занадто багато даних від користувача.
MyFitnessPal – це одна з найпопулярніших платформ для відстеження харчування і фізичної активності. Вона дозволяє користувачам вести щоденник харчування, відстежувати калорії та макронутрієнти, але не завжди забезпечує персоналізовані рекомендації.
Lifesum – це платформа, яка пропонує персоналізовані плани харчування, тренувань та поради зі здоров'я. Вона має інтуїтивний і користувацький дружній інтерфейс, але може бути дорожчою за інші альтернативи.
Проєкт Healfood фокусується на оптимізації процесів створення та керування персоналізованими дієтами та їх оновлення на основі складу тіла користувача. Наявні послуги мають такі нерозв'язані властивості, як:
– Підтримка додавання власних продуктів – можливість додавати власні продукти, окрім зареєстрованих компанією.
– Підтримка різних джерел щоденних значень – можливість використовувати іншу таблицю добових норм замість тієї, що надається УПМ.
– Автоматична адаптація дієти – моніторинг стану здоров'я користувача за допомогою наручного годинника, щоб адаптувати дієту до потреб користувача.
Задоволення цих незадоволених потреб є ключовим аспектом цього проєкту. Продукт буде монетизовано за допомогою стратегії Freemium, де більш персоналізований досвід можна отримати за допомогою преміум-функцій, таких як розширені аналітичні звіти, персоналізовані поради та підтримка.


1.1.2 Бізнес-цілі та критерії успіху

BO-1: Підтримка додавання власних продуктів – однією з основних бізнес-цілей є надання можливості користувачам додавати власні продукти до дієт. Мета - досягти збільшення кількості користувачів на 25% протягом першого року використання системи.
BO-2: Підтримка різних джерел щоденних значень – мета полягає у створенні можливості використовувати інші таблиці добових норм окрім тих, що надає УПМ. Планується досягти 20% збільшення задоволеності користувачів цією функцією протягом першого року.
BO-3: Автоматична адаптація дієти – Фокус на моніторингу стану здоров'я користувача. Планується досягти 70% збільшення користувачів, які активно використовують цю функцію протягом перших двох років.
SC-1: Задоволеність користувачів – успіх буде вимірюватися через задоволеність користувачів. Планується досягти не менше ніж 90% задоволеності користувачів цією платформою протягом першого року. Цей показник буде визначений через анкети та зворотний зв'язок від користувачів.
SC-2: Позитивний Рентабельний Показник – успіх проєкту буде вимірюватися позитивним ROI. Планується досягти ROI не менше ніж на 20% впродовж перших трьох років після впровадження.
SC-3: Зростання частки ринку – планується отримати не менше ніж 12% частки ринку відносно конкурентів протягом двох років після запуску продукту.
SC-4: Зростання активних користувачів – Планується досягти 35% зростання кількості активних користувачів протягом першого року використання системи.
Досягнення перевищення доходів над витратами щонайменше в 2 рази протягом перших двох років використання системи.


1.1.3 Потреби клієнтів або ринку

Цей проєкт включає наступних користувачів: звичайні користувачі, адміністратори та модератори

1.1.3.1 Потреби звичайних користувачів:

– Завантажити інтуїтивну мобільну програму для пошуку та створення дієт.
– Швидко та зручно отримати доступ до реального часу інформації про поживну цінність, доступність та ціни.
– Можливість налаштовувати та розширювати джерела інформації про харчові продукти.
– Отримати індивідуальні рекомендації для підвищення якості їхнього дозвілля.


1.1.3.2 Потреби модераторів:

– Можливість переглядати заявки на харчові продукти.
– Можливість змінювати та вилучати певні продукти, дієти.
– Можливість переглядати аналітику дієти.
– Можливість заборонити користувачам створювати заявки.

1.1.3.3 Потреби адміністраторів:

– Можливість переглядати, змінювати та видаляти будь-яку інформацію.
– Можливість відкликати та призначати модераторів.
– Можливість заборонити користувачам створювати заявки.
       

1.1.4 Бізнес-ризики

Розробка цього продукту супроводжується рядом ризиків, які можуть вплинути на успішність проєкту та бізнесу в цілому.

1.1.4.1 Ризики:

1. Інтенсивна конкуренція в галузі онлайн-систем створення дієт може суттєво вплинути на нашу позицію на ринку (середній ризик).
2. Нова платформа може не здобути достатньої популярності серед користувачів, що може вплинути на дохід (середній ризик).
3. Можливість кібератак або порушень в системі може викликати втрати даних та порушити конфіденційність користувачів (високий ризик).
4. Недостатня точність та ефективність рекомендацій дієт може призвести до незадовільних результатів користувачів (середній ризик).

1.1.4.2 Можливі рішення:

1. Розвивати унікальні конкурентні переваги, такі як вдосконалені алгоритми рекомендацій та підтримка міжнародних дієтологічних стандартів. Співпраця з партнерами та забезпечення вищого рівня обслуговування може зменшити цей ризик.
2. Здійснювати активну маркетингову кампанію та надавати привабливі пропозиції для залучення користувачів. Збирати та аналізувати зворотній зв'язок користувачів для вдосконалення продукту.
3. Забезпечувати високий рівень кібербезпеки, включаючи шифрування даних та регулярну перевірку на вразливості. Мати план відновлення після інциденту.
4. Проводити постійний моніторинг та аналіз ефективності рекомендацій дієт, щоб забезпечити їх високу точність та корисність для користувачів.
5. Забезпечити надійну і технічно справну платформу, проводячи регулярні технічні аудити та впроваджуючи системи моніторингу для виявлення та виправлення збоїв якнайшвидше.


1.2 Концепція рішення
1.2.1 Окреслення концепції

Програмна система Healfood створена для ефективного розв'язання проблем, пов'язаних з неефективністю та нестачею зручності при створенні та управлінні дієтами. Вона надає унікальний інструмент для користувачів, що дозволяє:
– Автоматично створювати персоналізовані дієти на основі індивідуальних потреб та пропозицій користувача.
– Легко порівнювати різноманітні дієти, враховуючи їхній склад, калорійність та поживну цінність.
– Адаптувати дієти в реальному часі на основі змін у складі тіла користувача, отриманих даних від наручного годинника.
Програмна система відзначається інтеграцією з більшістю дієтологічних таблиць, простим інтерфейсом та можливістю додавання власних продуктів. Вона розрахована на широкий коло користувачів, включаючи спортсменів, людей з медичними проблемами, а також звичайних користувачів, які прагнуть до здорового способу життя та правильного харчування.


1.2.2 Головна функціональність

MF-1: Створення профілю користувача – можливість реєстрації користувачів в системі з обов'язковим введенням особистих даних для створення облікового запису.
MF-2: Створення та управління дієтами – користувачі зможуть створювати, зберігати, редагувати та видаляти різноманітні дієти за допомогою зручного інтерфейсу.
MF-3: Підбір продуктів та рецептів – система надає рекомендації щодо продуктів та рецептів, які підходять для обраної дієти користувача.
MF-4: Моніторинг стану здоров'я – користувачі можуть вводити дані про своє здоров'я та фізичну активність для автоматичного адаптування рекомендацій дієт.
MF-5: Підтримка додавання власних продуктів – можливість додавати власні продукти до бази даних для персоналізації дієт.
MF-6: Автоматична адаптація дієти – система відстежує стан здоров'я користувача за допомогою наручного годинника для адаптації дієти до потреб користувача.
MF-7: Перегляд статистики та звітів – користувачі можуть переглядати статистику своєї дієти, успішності досягнення цілей та іншу аналітичну інформацію.
MF-8: Мобільний доступ до інформації – користувачі отримають негайний доступ до інформації про продукти, рецепти та рекомендації через мобільний додаток.
MF-9: Налаштування нагадувань та сповіщень – можливість встановлення нагадувань про приймання їжі, водного балансу та інших аспектів дієти.
MF-10: Підтримка різних джерел щоденних значень – можливість вибору таблиці добових норм замість тієї, що надається стандартною системою.
MF-11: Резервне копіювання даних – можливість створення резервних копій даних користувачів для запобігання втрати інформації та відновлення системи в разі потреби.
MF-12: Захист даних – використання передових технологій шифрування для захисту конфіденційності та цілісності даних користувачів, а також механізмів аутентифікації для забезпечення безпеки доступу до системи.


1.2.3 Припущення та залежності

П-1: Активне залучення користувачів – припускається, що користувачі будуть активно використовувати мобільний додаток та систему для створення та управління дієтами.
П-2: Доступ до Інтернету – припускається, що користувачі матимуть стабільний доступ до Інтернету для взаємодії з системою та отримання актуальних рекомендацій.
П-3: Правдивість даних – припускається, що інформація про продукти, рецепти та дієти, надавана системою, є правдивою та актуальною.
П-4: Готовність користувачів до змін в харчуванні – припускається, що користувачі готові адаптувати своє харчування відповідно до рекомендацій системи.
З-1: Розвиток підприємництва передбачає взаємодію з об'єктами харчування, які проявляють зацікавленість у впровадженні автоматизованих систем для підвищення ефективності та забезпечення комфорту користувачів.
З-2: Власники закладів харчування повинні встановити систему самостійно або залучити фахівців для цього.
З-3: Залежність від власників закладів харчування та споживачів є вирішальною для формування попиту на систему та можливості розширення її впровадження на ринку.
З-4: Співпраця з виробниками та постачальниками продуктів – припускається, що існує готовність співпрацювати з виробниками та постачальниками для надання актуальної та правдивої інформації про продукти.


1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску

Перша версія продукту буде фокусуватися на найважливіших функціях, які нададуть найбільшу цінність для користувачів та проєкту.
Серверна частина повинна включати:
    • Реєстрація та авторизація користувачів:
        а) створення облікового запису користувача з унікальним ідентифікатором.
        б) захищена авторизація через токени або сесії.
    • Управління даними щодо створення та управління дієтами:
        а) CRUD (створення, читання, оновлення, видалення) операції для дієт.
        б) алгоритми для автоматичного підбору продуктів на основі вказаної дієти.
    • Миттєвий доступ до інформації про продукти, рецепти та рекомендації:
        а) інтеграція з базою даних продуктів та рецептів.
        б) оптимізовані запити для швидкого доступу до інформації.
    • Екологічні критерії для підбору продуктів та рецептів:
        а) алгоритми оцінки екологічності продуктів.
        б) фільтрація та сортування продуктів за екологічними показниками.
    • Функції адміністрування:
        а) інтерфейс для додавання, редагування та видалення інформації про продукти та рецепти.
        б) модерація доданих користувачами даних із підтвердженням адміністратора.
IoT частина повинна включати:
    • Автоматична адаптація дієти на основі показників крові користувача:
        а) інтеграція з пристроями для зчитування показників крові.
        б) алгоритми аналізу даних для автоматичного коригування дієти.
Клієнтська частина повинна включати:
    • Інтерфейс для реєстрації та авторизації користувачів:
        а) UI/UX для введення та підтвердження даних користувача.
    • Можливість легкого створення та управління дієтами:
        а) інтуїтивний інтерфейс для додавання та редагування дієт.
    • Відображення актуальної інформації про продукти, рецепти та рекомендації:
        а) оптимізований візуальний інтерфейс для відображення даних.
    • Функціональність для пошуку продуктів та рецептів за екологічними критеріями:
    а) пошуковий двигун з можливістю фільтрації за екологічними показниками.
Мобільна частина повинна включати:
    • Мобільний додаток для користувачів на платформі Android:
    а) інтерфейс додатка, оптимізований для мобільних пристроїв.
    б) локальне зберігання даних для забезпечення швидкості та доступності інформації.


1.3.2 Рамки наступних випусків

– Розширення бази продуктів та рецептів – додавання нових продуктів та рецептів для більш різноманітної дієти.
– Покращення модерації та модульності – розробка і впровадження ефективних механізмів модерації для швидкого та точного схвалення продуктів та рецептів користувачів.
– Розширення функціональності IoT – інтеграція додаткових функцій IoT для більш точної адаптації дієти на основі показників крові користувача.
– Покращення функцій персоналізації – впровадження додаткових інструментів для персоналізації рекомендацій та дієт.
– Розробка версії додатка для iOS – розробка та випуск мобільного додатка для користувачів на платформі iOS.
– Співпраця з додатковими постачальниками продуктів – підключення нових постачальників продуктів для розширення вибору та якості інгредієнтів в дієті.
– Розширення можливостей співпраці з дієтологами та лікарями – додавання нових функцій для комунікації та консультацій з професіоналами у галузі харчування.


1.3.3 Обмеження та винятки

– Модерація даних – система передбачає необхідність модерації додаваних користувачами продуктів та дієт. Це може призвести до затримок у публікації нових продуктів та дієт у системі.
– Підтримка мобільних платформ – у першій версії обмежено підтримку операційних систем лише на платформі Android. Інші платформи можуть бути включені в майбутніх версіях.
– Масштабованість – система спроєктована для обслуговування певного обсягу користувачів і продуктів. При збільшенні обсягу можливе необхідне масштабування і розширення інфраструктури.
– Залежність від інтернет-з'єднання – використання системи вимагає наявності стабільного інтернет-з'єднання. Відсутність доступу до Інтернету може обмежити функціональність.
– Апаратні обмеження – деякі функції IoT можуть бути обмежені апаратними характеристиками пристроїв користувачів, такими як потужність пристроїв та доступні ресурси.



1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін

Таблиця 1.1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторона
Обмеження
Основні інтереси
Ставлення
Основна цінність
Звичайні користувачі
Доступ до мережі Інтернету
Підвищення доступності та, відповідно, популярності
Доступний сервіс для організації дієт
Швидка та надійна автоматизована система управління дієтами
Модератори
Доступ до мережі Інтернету
Покращення якості списку їжі та дієт
Зацікавленість якості харчових продуктів та переліків дієт
Швидка та проста система модерації
Адміністратори
Доступ до мережі Інтернету
Покращення користувацького досвіду 
Зацікавленість якості харчових продуктів та переліків дієт
Детальний інтерфейс з груповими діями
Розробники проєкту
Нестача досвіду, правові обмеження.
Заробіток, досвід
Зацікавленість в успіху сервісу та задоволеності користувачів
Гарний грошовий дохід і розширення бізнесу
Інвестори
Грошові обмеження
Заробіток
Зацікавленість в успіху сервісу та прибутку від нього
Отримання прибутку






1.4.2 Пріоритети проєкту

Таблиця 1.2 – Пріоритети проєкту
Показник
Виконання (етапи)
Обмеження (граничні значення)
Ступінь свободи (допустимий діапазон)
План робіт
продукт має бути випущеним до 10.06.2024
–
Відхилення від графіка на 1-2 місяці
Функціональність

–
90% функціоналу має бути реалізовано до релізу
Якість

–
Всі тести повинні бути пройдені при релізу
Розмір команди

Один розробник та адміністратор
–
Бюджет

60,000 грн.
Перевитрата бюджету до 15% є прийнятною без перевірки з боку керівництва


1.4.3 Робоче середовище

Прийматиме користувачів, які мають підключення до Інтернету. Для кращого використання необхідний переклад часу та інтерфейсу.
Дані будуть зберігатися в базі даних PostgreSQL в єдиному місці. Для забезпечення безпеки даних буде використане шифрування, аутентифікація та авторизація. Також будуть регулярно проводитися резервні копії даних, які будуть зберігатися в резервних сховищах. Перебої в роботі сервісу безпосередньо впливають на його безпеку і є неприпустимими.
Для розробки серверної частини буде використано Python Django та Django REST фреймворк, розроблений у Neovim.
Для розробки IoT буде використовуватися Arduino. Буде встановлено датчики для аналізу крові та датчик серцебиття. Код буде розроблено мовою програмування C++ використовуючи бібліотеку Arduino за допомогою Arduino IDE.
Для веб-додатку буде використано фреймворк Svelte.js з використанням Neovim.
Для мобільного додатку буде використано Jetpack Compose мовою програмування Kotlin з використанням Android Studio. Вибір Jetpack Compose та Kotlin обумовлено їх високою продуктивністю, простотою розробки та можливостями масштабування у контексті даного проєкту.
2 ПОСТАНОВКА ЗАДАЧІ


Відповідно до аналізу предметної області, основним завданням курсової роботи було розробити програмний комплекс для автоматизації створення раціону.
База даних повинна включати інформацію про: дієту, їжу, план харчування, харчову цінність, профіль, подання та користувача.
Застосунок повинен мати українську та англійську мови для інтерфейсу, інтегровані інструменти адміністрування системи (управління користувачами системи, управління даними системи, створення резервних копій налаштувань та даних, експорт та імпорт даних, налаштувань, управління сертифікатами). Також система включатиме інтернаціоналізацію та локалізацію, що охоплюватиме кодові таблиці символів, обчислення та формат дати та часу, місцевий та універсальний час, метричні одиниці вимірювання, англійську та американську системи мір, порядок сортування текстових значень та напрям введення тексту.






3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ


Для проєктування бази даних було розроблено ER-модель даних (див. рис. 3.1). Вона складається з семи таблиць: дієта, їжа, план харчування, харчова цінність, профіль, подання, користувач.
У базі даних наявні наступні зв’язки між сутностями:
— користувач та профіль мають зв’язок один до одного, бо один користувач може мати тільки один профіль;
— користувач та подання мають зв’язок один до багатьох, бо один користувач може мати декілька подань;
— профіль та харчова цінність мають зв’язок один до одного, бо один профіль може мати тільки одну харчову цінність;
— дієта та профіль мають зв’язок один до багатьох, бо одна дієта може мати декілька профілів;
— дієта та план харчування мають зв’язок один до багатьох, бо одна дієта може мати декілька планів харчування;
— план харчування та їжа мають зв’язок один до багатьох, бо один план харчування може мати декілька їж;
— їжа та харчова цінність мають зв’язок один до одного, бо одна їжа може мати тільки одну харчову цінність.

Рисунок 3.1 – ER-модель бази даних серверної частини
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
4.1 Архітектура серверної частини


Основними користувачами системи є 3 типи акторів: клієнти, менеджери, адміністратори.
Потреби клієнта: можливість переглядати доступні продукти та їхню поживну цінність, можливість створювати або обирати план харчування, можливість отримувати додаткові функції, такі як власні джерела даних; можливість отримувати персональні рекомендації.
Потреби менеджера: можливість керувати списками продуктів, можливість змінювати та перевіряти поживну цінність продуктів, можливість переглядати статистику різних дієт та їх популярність, можливість затверджувати або відхиляти запити на доповнення дієт.
Потреби адміністратора: можливість переглядати та контролювати користувачів системи, можливість переглядати та керувати харчовими продукти, можливість переглядати та керувати дієтами, можливість керувати глобальними джерелами даних, можливість створювати та відновлювати резервні копії, можливість призначати та відкликати менеджерів.
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. рис. 4.1).
Таким чином, за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою.



Рисунок 4.1 – Діаграма прецедентів для серверної частини системи

Для створення серверної частини системи було вибрано мову програмування Python, використовуючи технологію Django Framework.
Як базу даних було обрано MySQL, для взаємодії з нею з боку серверного додатка використовується Django ORM. Ця технологія надає зручний інтерфейс для роботи з базами даних у формі об'єктів сутностей.
Використані технології відображено на діаграмі розгортання (див. рис. 4.2).


Рисунок 4.2 — Діаграма розгортання серверної частини

Система складається із п'яти складових: веб-інтерфейсу, веб-сервера, бази даних, мобільного пристрою та ІоТ. На веб-сервері знаходиться серверна частина продукту, яка виконує основну бізнес-логіку. Веб-додаток надає користувачам доступ до інтерфейсу системи. Мобільний додаток дозволяє взаємодіяти з системою для перегляду інформації та навігації на місці відпочинку. Інтернет речей забезпечує безпеку та спрощує навігацію під час відпочинку. Архітектура серверного застосунку представлена на діаграмі пакетів (див. рис. 4.3).

Рисунок 4.3 — Діаграма пакетів серверної частини

Було виділено основні пакети, до яких відносяться: контролери (Views), маршрутизатори (Routers), сервіси (Services), репозиторії (Repositories), міграції (Migrations) та сервіс PlanetScale для розміщення бази даних.


4.2 Архітектура серверної частини

Основними користувачами системи є 2 типи акторів: клієнти та адміністратори.
Потреби клієнта: можливість отримувати оновлення дієти в режимі реального часу, можливість отримувати повідомлення користувачів про поганий рівень крові, можливість автоматично відстежувати план дієти.
Потреби адміністратора: можливість налаштування HTTP-адреси та порту сервера, можливість налаштування пов'язаного облікового запису, можливість перегляду журналів, можливість відстеження поточного рівня крові, можливість налаштування датчиків.
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. додат. 4.4).
Таким чином, за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою.

Рисунок 4.4 – Діаграма прецедентів для IoT частини системи

Для демонстрації можливостей інтернету речей (IoT) було вирішино реалізувати програмний продукт мовою програмування C, що оптимально використовує ресурси та максимально відповідає обмеженням апаратної частини пристроїв IoT. Основною метою цього вибору є забезпечення ефективної роботи на пристроях з обмеженими обчислювальними можливостями.
Для взаємодії з користувачем використовується інтерфейс командного рядка. Це дає можливість легко взаємодіяти з програмою, не витрачаючи зайвих ресурсів на графічний інтерфейс користувача.
Передача даних здійснюється за допомогою бібліотеки Curl. Це забезпечує надійну і швидку взаємодію з сервером чи іншими пристроями через мережу Інтернет. Дані передаються у форматі JSON, що є стандартом для обміну даними в інтернеті.
Програма розроблена з урахуванням мінімального обсягу коду з метою оптимізації для пристроїв з невеликою потужністю. Це дозволить забезпечити швидку та ефективну роботу на таких пристроях, зберігаючи водночас необхідний функціонал.
З метою подальшої адаптації для реальних пристроїв IoT програма розроблена таким чином, щоб її було легко портувати. Це дасть змогу швидко і без проблем впроваджувати її на різноманітні пристрої IoT з різними апаратними можливостями.

Для створення IoT частини системи було вибрано мову програмування C, компіляція відбувається за допомогою Clang.


Рисунок 4.5 – Діаграма пакетів для IoT частини системи

Для більш детальної візуалізації взаємодії пристрою з користувачами системи було розроблено діаграму взаємодії (див. додат. 4.6).
Також на основі взаємодії пристрою було побудовано діаграму діяльності, що відображає взаємодію пристрою з сервером (див. рис. 4.7).



Рисунок 4.6 – Діаграма взаємодії для IoT частини системи


Рисунок 4.7 – Діаграма діяльності для IoT частини системи

Таким чином, за допомогою діаграм пакетів, взаємодії та діяльності було визначено основні технології та архітектуру системи.


4.3 Архітектура клієнтської частини

Основними користувачами системи є 3 типи акторів: клієнти, менеджери та адміністратори.
Потреби клієнта: можливість перегляду дієт, можливість перегляду планів харчування, можливість перегляду записаної інформації користувача.
Потреби менеджера: можливість додавати, редагувати та видаляти продукти; можливість додавати, редагувати та видаляти дієти; можливість додавати та видаляти плани харчування.
Потреби адміністратора: можливість налаштування HTTP-адреси та порту сервера, можливість створювати резервні копії та відновлювати систему до певного стану.
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. додат. 4.8).
Таким чином, за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою.



Рисунок 4.8 – Діаграма прецедентів для клієнтської частини системи

Для написання клієнтської частини системи було обрано мову програмування TypeScript використовуючи технологію Sveltekit.
Для реалізації елементів інтерфейсу було використано бібліотеку Flowbite Svelte.
Для реалізації локалізації інтерфейсу було використано модуль i18n.ts.
Для зв'язку з API був розроблений модуль для виправляння запитів і обробки відповідей на основі fetch.
Для більш детальної візуалізації використаних компонентів було розроблено діаграму компонентів (див. додат. 4.9). Для візуалізації використаних пакетів було розроблено діаграму пакетів (див. рис. 4.10).



Рисунок 4.9 – Діаграма компонентів клієнтської частини


Рисунок 4.10 — Діаграма пакетів клієнтської частини

Для більш детальної візуалізації взаємодії станів користувачів у клієнтській частині системи було розроблено діаграму станів (див. рис. 4.11).


Рисунок 4.11 — Діаграма станів ролі користувача клієнтської частини

Таким чином, за допомогою діаграм пакетів, розгортання та станів було визначено основні технології та архітектуру системи.
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
5.1 Виклик і завантаження

Для початку отримайте репозиторій «https://github.com/NureOvcharenkoMykhailo/apzkr-pzpi-21-4-ovcharenko-mykhailo», або клонувавши його за допомогою Git, або завантаживши з сайту, натиснувши «download zip» і розпакувавши його десь на диску.
Щоб почати роботу з сервером, увійдіть в каталог «Task1-Server», встановіть Python 3.11.7 на ваш комп'ютер, а потім виконайте `python -m pip install -r requirements.lock`. Це повинно встановити середовище, після чого ви можете запустити `python server/manage.py runserver`.
Щоб почати роботу з розумним пристроєм, перейдіть до каталогу «Task2-IoT». Переконайтеся, що у вас встановлені GCC та Make, а потім запустіть `make build`. Вона повинна скомпілювати файл, після чого ви зможете запустити його за допомогою `./dist/iot`.
Для початку роботи з веб-клієнтом перейдіть в «Task3-WebClient», переконайтеся, що у вас встановлені Node.js і NPM, а потім запустіть `npm install`. Для запуску проєкту використовуйте `npm run dev`.
Після запуску всіх проєктів ви можете використовувати систему за допомогою веб-клієнта.


5.2 Призначення і логічна структура

Основна логіка системи розділена на наступні модулі:
− авторизація;
− інтерфейс прикладного програмування;
− резервні копії.
Модуль авторизації працює з користувачами, шифруванням і порівнянням паролів, а також валідацією токенів
Модуль інтерфейсу прикладного програмування містить кінцеві точки стандарту REST для зв'язку клієнтів з сервером. Він також надає інтерфейс для читання та запису до бази даних.
Модуль резервного копіювання відповідає за конвертацію даних бази даних у портативні формати CSV та відновлення бази даних до певного стану.


5.3 Опис програмної реалізації

При першому відвідуванні сайту користувач потрапляє на порожню сторінку, де йому потрібно авторизуватися в системі (див. рис. 5.1).


Рисунок 5.1 — Головна сторінка, коли ви не ввійшли в систему

Після переходу на сторінку входу користувач потрапляє на форму з полями для введення імені користувача та пароля (див. рис. 5.2).. Якщо користувач не має облікового запису, він може перейти на сторінку реєстрації (див. рис. 5.3).


Рисунок 5.2 — Сторінка входу


Рисунок 5.3 — Сторінка створення облікового запису

Сайт поверне користувача на головну сторінку, де ви зможете побачити свій рівень крові та різні дані (див. рис. 5.4).


Рисунок 5.4 — Головна сторінка

Перейшовши на сторінку дієт, ви можете переглянути всі чинні дієти та відкрити їх. Кожна картка містить інформацію про дієту, її середню калорійність, розраховану за допомогою статистичних функцій на основі продуктів, що містяться в ній, та мініатюру. (див. рис. 5.5).


Рисунок 5.5 — Фрагмент дієтичної картки

Ви також можете перейти на сторінку харчових продуктів, де ви можете перерахувати всі продукти (див. рис. 5.6). А також сторінка редагування для менеджерів (див. рис. 5.7).


Рисунок 5.6 — Фрагмент картки харчового продукту


Рисунок 5.7 — Фрагмент сторінки редагування їжі

Також є сторінка з планами харчування, які ви можете переглянути, ці плани містять певну дієту в певний час дня (див. рис. 5.8).


Рисунок 5.8 — Фрагмент сторінки плану харчування

Якщо користувач є адміністратором, він отримує доступ до панелі адміністратора (див. рис. 5.9), де він може створювати резервні копії певних таблиць бази даних (див. рис. 5.10). А також відновлювати ці таблиці до певного стану.


Рисунок 5.9 — Фрагмент сторінки панелі адміністратора

Рисунок 5.10 — Приклад резервного копіювання користувачів
ВИСНОВКИ


За результатами роботи було створено програмний комплекс для створення та автоматичного управління раціонами харчування.
Під час проєкту було досліджено предметну область, створено структуру бази даних та спроєктовано архітектуру програмної системи, що включає модулі моніторингу та користувацького інтерфейсу. Було реалізовано систему за допомогою мов програмування Python, TypeScript та C.
Вся робота дозволяє в режимі реального часу контролювати рівень крові користувача. Користувач може переглядати дієти, продукти та плани харчування. Система дозволяє реєструвати користувачів і входити в систему. Менеджери можуть змінювати різні дані в системі за допомогою простого у використанні інтерфейсу. Адміністратори мають можливість створювати резервні копії та відкочувати систему до певного стану. Всі користувачі можуть налаштувати IP-адресу та мову сервера з підтримкою локалізації.
Таким чином, розроблений програмний комплекс Healfood покликаний ефективно розв'язати проблеми, пов'язані з неефективністю та недостатньою зручністю у створенні та управлінні раціонами.

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1. PostgreSQL 16.3 Documentation. PostgreSQL Documentation. URL: https://www.postgresql.org/docs/16/index.html (дата звернення: 20.06.2024).
2. Django Framework documentation. URL: https://docs.djangoproject.com/en/5.0/ (дата звернення: 20.06.2024).
3. Vite js documentation. URL: https://vitejs.dev/ (дата звернення: 20.06.2024).
4. Design Patterns: Elements of Reusable Object-Oriented Software (AddisonWesley Professional Computing Series) / R. Helm та ін. Addison-Wesley Professional, 1995. 395 р.
5. Kamal R. Embedded Systems - Architecture, Programming and Design. Tata McGraw Hill, 2008.
6. Репозиторій з програмним кодом курсової роботи. URL: https://github.com/NureOvcharenkoMykhailo/apzkr-pzpi-21-4-ovcharenko-mykhailo (дата звернення: 20.06.2024).
7. Відео із демонстрацією програмного веб-застосунка. URL: https://youtu.be/Gyl7r-eZxKA (дата звернення: 20.06.2024).
ДОДАТОК А
Знімок з екрана перевірки плагіату
ф
ДОДАТОК Б
Програмний код серверної частини

В.1 Код ORM моделей бази даних models.py.
1 from django.db import models
2
3 ROLE_CHOICES = (
4     (0, "user"),
5     (1, "manager"),
6     (2, "admin"),
7 )
8
9 TIME_CHOICES = (
10     (0, "breakfast"),
11     (1, "lunch"),
12     (2, "snack"),
13     (3, "dinner"),
14 )
15
16
17 class Model:
18     objects = models.Manager()
19
20     @classmethod
21     def secure_get(cls, multiple: bool = False, **kwargs):
22         if multiple:
23             return cls.objects.filter(**kwargs).all()
24         return cls.objects.filter(**kwargs).first()
25
26
27 class User(models.Model, Model):
28     user_id = models.CharField(primary_key=True, max_length=16)
29     email = models.EmailField(unique=True)
30     password = models.CharField(max_length=60)
31     first_name = models.CharField(max_length=32)
32     last_name = models.CharField(max_length=32)
33     weight = models.FloatField(null=True, blank=True)
34     body_fat = models.FloatField(null=True, blank=True)
35     blood_pressure = models.IntegerField(null=True, blank=True)
36     heart_rate = models.IntegerField(null=True, blank=True)
37     oxygen_level = models.IntegerField(null=True, blank=True)
38     role = models.SmallIntegerField(default=0)  # type: ignore
39     date_of_birth = models.DateField()
40     created_at = models.DateTimeField(auto_now_add=True)
41     updated_at = models.DateTimeField(auto_now=True)
42     last_seen_at = models.DateTimeField(auto_now_add=True)
43
44     class Meta:
45         db_table = "User"
46
47     @property
48     def token(self):
49         return f"@{self.user_id}:{self.password}"
50
51
52 class Profile(models.Model, Model):
53     profile_id = models.BigAutoField(primary_key=True)
54     preferences = models.JSONField(default=dict)
55     fk_diet = models.ForeignKey("Diet", on_delete=models.CASCADE, null=True, blank=True)
56     fk_nutrition = models.ForeignKey(
57         "Nutrition", on_delete=models.SET_NULL, null=True, blank=True
58     )
59     fk_user = models.ForeignKey("User", on_delete=models.CASCADE)
60
61     class Meta:
62         db_table = "Profile"
63
64
65 class Diet(models.Model, Model):
66     diet_id = models.BigAutoField(primary_key=True)
67     name = models.CharField(max_length=32)
68     description = models.TextField(default="", blank=True)
69     photo_url = models.TextField()
70
71     class Meta:
72         db_table = "Diet"
73
74
75 class MealPlan(models.Model, Model):
76     meal_plan_id = models.BigAutoField(primary_key=True)
77     time = models.SmallIntegerField(default=0, choices=TIME_CHOICES)  # type: ignore
78     fk_diet = models.ForeignKey("Diet", on_delete=models.CASCADE)
79     foods = models.TextField()
80
81     class Meta:
82         db_table = "MealPlan"
83
84     def get_foods(self) -> list["Food"]:
85         diets = [
86             Food.secure_get(food_id=int(i)) for i in str(self.foods).split(",") if i
87         ]
88         return [i for i in diets if i]
89
90
91 class Submission(models.Model, Model):
92     submission_id = models.BigAutoField(primary_key=True)
93     note = models.TextField()
94     reviewer = models.CharField(max_length=16, null=True, blank=True)
95     fk_user = models.ForeignKey("User", on_delete=models.CASCADE)
96     is_accepted = models.BooleanField(default=False)  # type: ignore
97
98     class Meta:
99         db_table = "Submission"
100
101
102 class Food(models.Model, Model):
103     food_id = models.BigAutoField(primary_key=True)
104     name = models.CharField(max_length=32)
105     description = models.TextField()
106     photo_url = models.TextField()
107     carbs = models.FloatField()
108     protein = models.FloatField()
109     fat = models.FloatField()
110     calories = models.FloatField()
111     fk_nutrition = models.ForeignKey("Nutrition", on_delete=models.SET_NULL, null=True)
112
113     class Meta:
114         db_table = "Food"
115
116
117 class Nutrition(models.Model, Model):
118     nutrition_id = models.BigAutoField(primary_key=True)
119     vitamins = models.JSONField(default=dict)
120     minerals = models.JSONField(default=dict)
121     amino_acids = models.JSONField(default=dict)
122
123     class Meta:
124         db_table = "Nutrition"


В.2 Код шаблонів url urls.py.
1 from django.urls import path
2
3 from .views import *
4
5 urlpatterns = [
6     *AccountView.get_url_patterns(),
7     *FoodView.get_url_patterns(),
8     *SubmissionView.get_url_patterns(),
9     *DietView.get_url_patterns(),
10     *MealPlanView.get_url_patterns(),
11     *SystemView.get_url_patterns(),
12     *IotView.get_url_patterns(),
13 ]


В.3 Код поглядів views.py.
1 from typing import Union
2
3 import tablib
4 from rest_framework.serializers import ModelSerializer
5
6 from .admin import *
7 from .models import Diet, Food, MealPlan, Nutrition, Profile, Submission
8 from .serializers import *
9 from .utils import *
10
11
12 def get_user(user_id: str, lang) -> tuple[int, Union[dict, User]]:
13     query_user: User = User.secure_get(user_id=user_id)
14
15     if not query_user:
16         return 404, {"error": lang.translate("user.not_found", user_id)}
17
18     return 200, query_user
19
20
21 def get_all(
22     query_id: str, results: list, serializer: type[ModelSerializer], lang: Lang
23 ):
24     parts = query_id.split(":")
25     if len(parts) != 2 and [True for part in parts if not part.isnumeric()]:
26         return 409, {
27             "error": "Invalid format, must be: `[page]:[size]`",
28         }
29     page, size = int(parts[0]), int(parts[1])
30     return 200, {
31         "overflow": max(0, len(results) - (page * size) - size),
32         "results": [
33             serializer(lang, food).data for food in results[page : page + size]
34         ],
35     }
36
37
38 class AccountView(View):
39     class Register(Args):
40         user_id: str = ValidString(16)  # type: ignore
41         password: str = ValidPassword()  # type: ignore
42         email: str = ValidEmail()  # type: ignore
43         first_name: str = ValidString(32)  # type: ignore
44         last_name: str = ValidString(32)  # type: ignore
45         date_of_birth: str = ValidDate()  # type: ignore
46
47     def post_register(self, post: Register):
48         if User.secure_get(user_id=post.user_id) or User.secure_get(email=post.email):
49             return 409, {
50                 "error": self.lang.translate("user.already_exists", post.user_id)
51             }
52
53         user = User(**post.as_dict(filters=["password", "date_of_birth"]))
54         user.date_of_birth = datetime.datetime(*[int(i) for i in reversed(post.date_of_birth.split("/"))])  # type: ignore
55         user.password = str(Password.encrypt(post.password), encoding="utf-8")  # type: ignore
56         user.save()
57
58         return 200, {"token": user.token}
59
60     class Login(Args):
61         user_id: str = ValidString(16)  # type: ignore
62         password: str = ValidPassword()  # type: ignore
63
64     def post_login(self, post: Login):
65         user: User = User.secure_get(user_id=post.user_id)
66         if not user:
67             return 404, {"error": self.lang.translate("user.not_found", post.user_id)}
68
69         if not Password.compare(str(user.password), post.password):
70             return 409, {"error": self.lang.translate("user.wrong_password")}
71
72         return 200, {"token": user.token}
73
74     def delete_delete(self, user: User, query_id: str):
75         if not user.role == 2:
76             return 403, {"error": self.lang.translate("user.no_permission")}
77
78         code, query = get_user(query_id, self.lang)
79         if code != 200:
80             return code, query
81
82         cast(User, query).delete()
83         return 200, {}
84
85     def get_query(self, query_id: str):
86         code, query = get_user(query_id, self.lang)
87         if code != 200:
88             return code, query
89
90         return 200, UserSerializer(self.lang, query).data
91
92     def get_all(self, query_id: str):
93         return get_all(query_id, User.objects.all(), UserSerializer, self.lang)
94
95     class Edit(Args):
96         user_id: str = ValidString(16)  # type: ignore
97         password: str = ValidPassword(is_optional=True)  # type: ignore
98         email: str = ValidEmail(is_optional=True)  # type: ignore
99         first_name: str = ValidString(32, is_optional=True)  # type: ignore
100         last_name: str = ValidString(32, is_optional=True)  # type: ignore
101         date_of_birth: str = ValidDate(is_optional=True)  # type: ignore
102         role: int = ValidInteger(is_optional=True)  # type: ignore
103
104     def post_edit(self, post: Edit, user: User):
105         query_user: User = User.secure_get(user_id=post.user_id)
106         if not query_user:
107             return 404, {"error": self.lang.translate("user.not_found", post.user_id)}
108
109         if user.user_id != query_user.user_id and user.role != 2:
110             return 403, {"error": self.lang.translate("user.no_permission")}
111
112         if post.email:
113             query_user.email = post.email  # type: ignore
114         if post.first_name:
115             query_user.first_name = post.first_name  # type: ignore
116         if post.last_name:
117             query_user.last_name = post.last_name  # type: ignore
118         if post.date_of_birth:
119             query_user.date_of_birth = datetime.datetime(*[int(i) for i in reversed(post.date_of_birth.split("/"))])  # type: ignore
120         if post.password:
121             query_user.password = str(Password.encrypt(post.password), encoding="utf-8")  # type: ignore
122         if post.role is not None and user.role == 2 and post.role in [0, 1, 2]:
123             query_user.role = post.role  # type: ignore
124         query_user.save()
125
126         return 200, UserSerializer(self.lang, query_user).data
127
128     def get_profile(self, query_id: str):
129         code, query = get_user(query_id, self.lang)
130         if code != 200:
131             return code, query
132
133         profile = Profile.secure_get(fk_user=query)
134         if profile is None:
135             profile = Profile(fk_user=query)
136             profile.save()
137
138         return 200, ProfileSerializer(self.lang, profile).data
139
140
141 class FoodView(View):
142     class Create(Args):
143         name: str = ValidString(32)  # type: ignore
144         description: str = ValidString()  # type: ignore
145         photo_url: str = ValidUrl()  # type: ignore
146         carbs: str = ValidFloat()  # type: ignore
147         protein: str = ValidFloat()  # type: ignore
148         fat: str = ValidFloat()  # type: ignore
149         calories: str = ValidFloat()  # type: ignore
150         vitamins: str = ValidJson({i: ValidFloat() for i in VITAMINS})  # type: ignore
151         minerals: str = ValidJson({i: ValidFloat() for i in MINERALS})  # type: ignore
152         amino_acids: str = ValidJson({i: ValidFloat() for i in AMINO_ACIDS})  # type: ignore
153
154     def post_create(self, post: Create, user: User):
155         if user.role == 0:
156             return 403, {"error": self.lang.translate("user.no_permission")}
157
158         food = Food(**post.as_dict(filters=["vitamins", "minerals", "amino_acids"]))
159         nutrition = Nutrition(
160             vitamins=json.dumps(post.vitamins),
161             minerals=json.dumps(post.minerals),
162             amino_acids=json.dumps(post.amino_acids),
163         )
164         nutrition.save()
165
166         food.fk_nutrition = nutrition  # type: ignore
167         food.save()
168         return 200, FoodSerializer(self.lang, food).data
169
170     def get_query(self, query_id: int):
171         food = Food.secure_get(food_id=query_id)
172
173         if food is None:
174             return 404, {"error": self.lang.translate("generic.not_found", query_id)}
175
176         return 200, FoodSerializer(self.lang, food).data
177
178     def get_all(self, query_id: str):
179         return get_all(query_id, Food.objects.all(), FoodSerializer, self.lang)
180
181     def delete_delete(self, user: User, query_id: int):
182         if user.role == 0:
183             return 403, {"error": self.lang.translate("user.no_permission")}
184
185         food: Food = Food.secure_get(food_id=query_id)
186
187         if food is None:
188             return 404, {"error": self.lang.translate("generic.not_found", query_id)}
189
190         food.fk_nutrition.delete()  # type: ignore
191         food.delete()
192
193         return 200, {}
194
195     class Edit(Args):
196         food_id: str = ValidInteger()  # type: ignore
197         name: str = ValidString(32, is_optional=True)  # type: ignore
198         description: str = ValidString(is_optional=True)  # type: ignore
199         photo_url: str = ValidUrl(is_optional=True)  # type: ignore
200         carbs: str = ValidFloat(is_optional=True)  # type: ignore
201         protein: str = ValidFloat(is_optional=True)  # type: ignore
202         fat: str = ValidFloat(is_optional=True)  # type: ignore
203         calories: str = ValidFloat(is_optional=True)  # type: ignore
204         vitamins: str = ValidJson({i: ValidFloat() for i in VITAMINS}, is_optional=True)  # type: ignore
205         minerals: str = ValidJson({i: ValidFloat() for i in MINERALS}, is_optional=True)  # type: ignore
206         amino_acids: str = ValidJson({i: ValidFloat() for i in AMINO_ACIDS}, is_optional=True)  # type: ignore
207
208     def post_edit(self, post: Edit, user: User):
209         if user.role == 0:
210             return 403, {"error": self.lang.translate("user.no_permission")}
211
212         food: Food = Food.secure_get(food_id=post.food_id)
213         if food is None:
214             return 404, {
215                 "error": self.lang.translate("generic.not_found", post.food_id)
216             }
217
218         if post.name:
219             food.name = post.name  # type: ignore
220         if post.description:
221             food.description = post.description  # type: ignore
222         if post.photo_url:
223             food.photo_url = post.photo_url  # type: ignore
224         if post.carbs:
225             food.carbs = post.carbs  # type: ignore
226         if post.protein:
227             food.protein = post.protein  # type: ignore
228         if post.fat:
229             food.fat = post.fat  # type: ignore
230         if post.calories:
231             food.calories = post.calories  # type: ignore
232         if post.vitamins:
233             food.fk_nutrition.vitamins = json.dumps(post.vitamins)  # type: ignore
234         if post.minerals:
235             food.fk_nutrition.minerals = json.dumps(post.minerals)  # type: ignore
236         if post.amino_acids:
237             food.fk_nutrition.amino_acids = json.dumps(post.amino_acids)  # type: ignore
238
239         return 200, FoodSerializer(self.lang, food).data
240
241
242 class SubmissionView(View):
243     class Create(Args):
244         note: str = ValidString()  # type: ignore
245
246     def post_create(self, post: Create, user: User):
247         submission = Submission(note=post.note, fk_user=user)
248         submission.save()
249
250         return 200, SubmissionSerializer(self.lang, submission).data
251
252     def get_query(self, query_id: str):
253         submission = Submission.secure_get(submission_id=query_id)
254
255         if submission is None:
256             return 404, {"error": self.lang.translate("generic.not_found", query_id)}
257
258         return 200, SubmissionSerializer(self.lang, submission).data
259
260     def get_all(self, query_id: str):
261         return get_all(
262             query_id, Submission.objects.all(), SubmissionSerializer, self.lang
263         )
264
265     def delete_delete(self, user: User, query_id: str):
266         submission: Submission = Submission.secure_get(submission_id=query_id)
267         if user.role == 0 and submission.fk_user.user_id != user.user_id:  # type: ignore
268             return 403, {"error": self.lang.translate("user.no_permission")}
269
270         if submission is None:
271             return 404, {"error": self.lang.translate("generic.not_found", query_id)}
272
273         submission.delete()
274
275         return 200, {}
276
277     class Edit(Args):
278         submission_id: str = ValidInteger()  # type: ignore
279         note: str = ValidString(is_optional=True)  # type: ignore
280         is_accepted: str = ValidBoolean(is_optional=True)  # type: ignore
281
282     def post_edit(self, post: Edit, user: User):
283         submission: Submission = Submission.secure_get(submission_id=post.submission_id)
284         if user.role == 0 and submission.fk_user.user_id != user.user_id:  # type: ignore
285             return 403, {"error": self.lang.translate("user.no_permission")}
286
287         if submission is None:
288             return 404, {
289                 "error": self.lang.translate("generic.not_found", post.submission_id)
290             }
291
292         if post.note:
293             submission.note = post.note  # type: ignore
294         if post.is_accepted:
295             if post.is_accepted:
296                 submission.reviewer = user.user_id
297             if not post.is_accepted:
298                 submission.reviewer = None  # type: ignore
299             submission.is_accepted = post.is_accepted  # type: ignore
300         submission.save()
301
302         return 200, SubmissionSerializer(self.lang, submission).data
303
304
305 class DietView(View):
306     class Create(Args):
307         name: str = ValidString(32)  # type: ignore
308         description: str = ValidString(is_optional=True)  # type: ignore
309         photo_url: str = ValidUrl()  # type: ignore
310
311     def post_create(self, post: Create, user: User):
312         if user.role == 0:  # type: ignore
313             return 403, {"error": self.lang.translate("user.no_permission")}
314
315         diet = Diet(**post.as_dict())
316         diet.save()
317
318         return 200, DietSerializer(self.lang, diet).data
319
320     def get_query(self, query_id: str):
321         diet = Diet.secure_get(diet_id=query_id)
322
323         if diet is None:
324             return 404, {"error": self.lang.translate("generic.not_found", query_id)}
325
326         return 200, DietSerializer(self.lang, diet).data
327
328     def get_all(self, query_id: str):
329         return get_all(query_id, Diet.objects.all(), DietSerializer, self.lang)
330
331     class Edit(Args):
332         diet_id: str = ValidInteger()  # type: ignore
333         name: str = ValidString(32, is_optional=True)  # type: ignore
334         description: str = ValidString(is_optional=True)  # type: ignore
335         photo_url: str = ValidUrl(is_optional=True)  # type: ignore
336
337     def post_edit(self, post: Edit, user: User):
338         if user.role == 0:  # type: ignore
339             return 403, {"error": self.lang.translate("user.no_permission")}
340
341         diet: Diet = Diet.secure_get(diet_id=post.diet_id)
342
343         if diet is None:
344             return 404, {
345                 "error": self.lang.translate("generic.not_found", post.diet_id)
346             }
347
348         if post.name:
349             diet.name = post.name  # type: ignore
350         if post.description:
351             diet.description = post.description  # type: ignore
352         if post.photo_url:
353             diet.photo_url = post.photo_url  # type: ignore
354
355         diet.save()
356
357         return 200, DietSerializer(self.lang, diet).data
358
359     def delete_delete(self, user: User, query_id: str):
360         if user.role == 0:  # type: ignore
361             return 403, {"error": self.lang.translate("user.no_permission")}
362
363         diet: Diet = Diet.secure_get(diet_id=query_id)
364
365         if diet is None:
366             return 404, {"error": self.lang.translate("generic.not_found", query_id)}
367
368         diet.delete()
369
370         return 200, {}
371
372
373 class MealPlanView(View):
374     class Create(Args):
375         time: str = ValidMealTime()  # type: ignore
376         diet_id: str = ValidInteger()  # type: ignore
377         foods: str = ValidList()  # type: ignore
378
379     def post_create(self, post: Create, user: User):
380         if user.role == 0:  # type: ignore
381             return 403, {"error": self.lang.translate("user.no_permission")}
382
383         diet = Diet.secure_get(diet_id=post.diet_id)
384
385         if diet is None:
386             return 404, {
387                 "error": self.lang.translate("generic.not_found", post.diet_id)
388             }
389
390         meal_plan = MealPlan(
391             time=post.time, fk_diet=diet, foods=",".join([str(i) for i in post.foods])
392         )
393         meal_plan.save()
394
395         return 200, MealPlanSerializer(self.lang, meal_plan).data
396
397     def get_query(self, query_id: str):
398         meal_plan = MealPlan.secure_get(meal_plan_id=query_id)
399
400         if meal_plan is None:
401             return 404, {"error": self.lang.translate("generic.not_found", query_id)}
402
403         return 200, MealPlanSerializer(self.lang, meal_plan).data
404
405     def get_all(self, query_id: str):
406         return get_all(query_id, MealPlan.objects.all(), MealPlanSerializer, self.lang)
407
408     def delete_delete(self, query_id: str):
409         meal_plan = MealPlan.secure_get(meal_plan_id=query_id)
410
411         if meal_plan is None:
412             return 404, {"error": self.lang.translate("generic.not_found", query_id)}
413
414         meal_plan.delete()
415
416         return 200, {}
417
418
419 class SystemView(View):
420     def get_backup(self, user: User, query_id: str):
421         if user.role != 2:
422             return 403, {"error": self.lang.translate("user.no_permission")}
423
424         match query_id:
425             case "users":
426                 return 201, UserResource().export(format="csv").csv  # type: ignore
427             case "profiles":
428                 return 201, ProfileResource().export(format="csv").csv  # type: ignore
429             case "diets":
430                 return 201, DietResource().export(format="csv").csv  # type: ignore
431             case "meal_plans":
432                 return 201, MealPlanResource().export(format="csv").csv  # type: ignore
433             case "submissions":
434                 return 201, SubmissionResource().export(format="csv").csv  # type: ignore
435             case "foods":
436                 return 201, FoodResource().export(format="csv").csv  # type: ignore
437             case "nutritions":
438                 return 201, NutritionResource().export(format="csv").csv  # type: ignore
439             case _:
440                 return 201, ""
441
442     class Rollback(Args):
443         resource: str = ValidString()  # type: ignore
444         data: str = ValidString()  # type: ignore
445
446     def post_rollback(self, post: Rollback, user: User):
447         if user.role != 2:
448             return 403, {"error": self.lang.translate("user.no_permission")}
449
450         data = tablib.Dataset()
451         data.csv = post.data  # type: ignore
452
453         match post.resource:
454             case "users":
455                 return 200, {
456                     "has_errors": UserResource().import_data(data).has_errors()  # type: ignore
457                 }
458             case "profiles":
459                 return 200, {
460                     "has_errors": ProfileResource().import_data(data).has_errors()  # type: ignore
461                 }
462             case "diets":
463                 return 200, {
464                     "has_errors": DietResource().import_data(data).has_errors()  # type: ignore
465                 }
466             case "meal_plans":
467                 return 200, {
468                     "has_errors": MealPlanResource().import_data(data).has_errors()  # type: ignore
469                 }
470             case "submissions":
471                 return 200, {
472                     "has_errors": SubmissionResource().import_data(data).has_errors()  # type: ignore
473                 }
474             case "foods":
475                 return 200, {
476                     "has_errors": FoodResource().import_data(data).has_errors()  # type: ignore
477                 }
478             case "nutritions":
479                 return 200, {
480                     "has_errors": NutritionResource().import_data(data).has_errors()  # type: ignore
481                 }
482             case _:
483                 return 201, ""
484
485
486 class IotView(View):
487     class Update(Args):
488         user_id: str = ValidString(16)  # type: ignore
489         blood_pressure: int = ValidInteger()  # type: ignore
490         heart_rate: int = ValidInteger()  # type: ignore
491         oxygen_level: int = ValidInteger()  # type: ignore
492
493     def post_update(self, post: Update):
494         query_user: User = User.secure_get(user_id=post.user_id)
495         if query_user is None:
496             return 404, {"error": self.lang.translate("user.not_found", post.user_id)}
497
498         query_user.heart_rate = post.heart_rate  # type: ignore
499         query_user.oxygen_level = post.oxygen_level  # type: ignore
500         query_user.blood_pressure = post.blood_pressure  # type: ignore
501         query_user.save()
502
503         return 200, UserSerializer(self.lang, query_user).data


В.4 Код перекладу відповідей та іх управління lang.py.
1 from typing import cast
2
3 TRANSLATIONS = {
4     "us": {
5         "arg.not_found": "Argument is required, but not found in POST data.",
6         "arg.invalid_value": "Argument of type {}({}) has invalid value.",
7         "user.already_exists": "User '@{}' already exists.",
8         "user.not_found": "User '@{}' not found.",
9         "user.wrong_password": "Wrong password.",
10         "user.not_authenticated": "You must be authenticated to access this page.",
11         "user.no_permission": "You don't have permissions to access this page.",
12         "generic.not_found": "Not found.",
13         "role.0": "User",
14         "role.1": "Manager",
15         "role.2": "Admin",
16     },
17     "ua": {
18         "arg.not_found": "Необхідно вказати аргумент, але його немає в даних POST.",
19         "arg.invalid_value": "Аргумент типу {}({}) має недійсне значення.",
20         "user.already_exists": "Користувач '@{}' вже існує.",
21         "user.not_found": "Користувача '@{}' не знайдено.",
22         "user.wrong_password": "Неправильний пароль.",
23         "user.not_authenticated": "Вам потрібно автентифікуватися, щоб отримати доступ до цієї сторінки.",
24         "user.no_permission": "У вас немає прав доступу до цієї сторінки.",
25         "generic.not_found": "Не знайдено.",
26         "role.0": "Користувач",
27         "role.1": "Керівник",
28         "role.2": "Адміністратор",
29     },
30 }
31
32
33 class Lang:
34     def __init__(self, lang: str):
35         self.table = cast(dict, TRANSLATIONS.get(lang, TRANSLATIONS.get("us")))
36
37     def translate(self, key: str, *args, **kwargs):
38         default = TRANSLATIONS["us"].get(key)
39         value = self.table.get(key, default)
40         if not value:
41             return f"<{key}>"
42         return value.format(*args, **kwargs)


В.5 Код кодування та перевірки паролів password.py.
1 import bcrypt
2
3
4 class Password:
5     @staticmethod
6     def encrypt(password: str) -> bytes:
7         return bcrypt.hashpw(bytes(password, encoding="utf-8"), bcrypt.gensalt())
8
9     @staticmethod
10     def compare(hashed: str, password: str) -> bool:
11         return bcrypt.checkpw(
12             bytes(password, encoding="utf-8"), bytes(hashed, encoding="utf-8")
13         )


В.6 Код, який перевіряє правильність значень POST-запитів validators.py.
1 import datetime
2 import math
3 from typing import Callable, cast
4
5 from django.core.exceptions import ValidationError
6 from django.core.validators import validate_email
7 from django.http.response import json
8
9 VITAMINS = [
10     "vitamin_a",
11     "vitamin_b6",
12     "vitamin_b12",
13     "vitamin_c",
14     "vitamin_d",
15     "vitamin_e",
16     "vitamin_k1",
17     "betaine",
18     "choline",
19     "folate",
20     "thiamin",
21     "riboflavin",
22     "pantothenic_acid",
23     "niacin",
24 ]
25
26 MINERALS = [
27     "calcium",
28     "copper",
29     "fluoride",
30     "iron",
31     "magnesium",
32     "manganese",
33     "phosphorus",
34     "potassium",
35     "selenium",
36     "sodium",
37     "zinc",
38 ]
39
40 AMINO_ACIDS = [
41     "alanine",
42     "arginine",
43     "aspartic_acid",
44     "cystine",
45     "glutamic_acid",
46     "glycine",
47     "histidine",
48     "isoleucine",
49     "leucine",
50     "lysine",
51     "methionine",
52     "phenylalanine",
53     "proline",
54     "serine",
55     "threonine",
56     "tyrosine",
57     "valine",
58 ]
59
60
61 class ValidValue:
62     def __init__(self, is_optional: bool = False):
63         self.value = None
64         self.is_optional = is_optional
65
66     def __str__(self) -> str:
67         return f"<{self.__class__.__name__[5:].lower()}>"
68
69     def __repr__(self) -> str:
70         return self.__str__()
71
72     @property
73     def variables(self):
74         return {
75             k: v
76             for k, v in self.__dict__.items()
77             if k not in ["value", "is_optional", "keys"]
78         }
79
80     def validate(self, value: str) -> bool:
81         return True
82
83     def get_valid_value(
84         self, add_error: Callable, data: dict, name: str, parent: str = ""
85     ):
86         error_name = ".".join([i for i in [parent, name] if i])
87         if data.get(name) is None:
88             if not self.is_optional:
89                 add_error(error_name, "arg.not_found")
90             return None
91         if not self.validate(data.get(name) or ""):
92             add_error(
93                 error_name,
94                 "arg.invalid_value",
95                 self.__class__.__name__[5:],
96                 "; ".join(
97                     [
98                         "=".join((key, str(value)))
99                         for key, value in self.variables.items()
100                     ]
101                 ),
102             )
103         return self.value
104
105
106 class ValidId(ValidValue):
107     def __init__(self, model, key: str, key_type: type, is_optional: bool = False):
108         self.model = model
109         self.key = key
110         self.key_type = key_type
111         super().__init__(is_optional)
112
113     def validate(self, value: str):
114         instance = self.model.secure_get(**{self.key: self.key_type(value)})
115         if not instance:
116             return False
117         self.value = instance
118         return True
119
120
121 class ValidString(ValidValue):
122     def __init__(self, max_length: int = 2147483648, is_optional: bool = False):
123         self.max_length = max_length
124         super().__init__(is_optional=is_optional)
125
126     def validate(self, value: str) -> bool:
127         self.value = value
128         return len(value) <= self.max_length
129
130
131 class ValidInteger(ValidValue):
132     def validate(self, value: str) -> bool:
133         try:
134             self.value = int(value or "0")
135         except ValueError:
136             return False
137         return True
138
139
140 class ValidFloat(ValidValue):
141     def validate(self, value: str) -> bool:
142         try:
143             self.value = float(value or "0.0")
144         except ValueError:
145             return False
146         return True
147
148
149 class ValidUrl(ValidValue):
150     def validate(self, value: str) -> bool:
151         self.value = value
152         return value.startswith("https://")
153
154
155 class ValidPassword(ValidValue):
156     @staticmethod
157     def _get_entropy(password: str):
158         return math.log2(len(set(password)) ** len(password))
159
160     def validate(self, value: str) -> bool:
161         self.value = value
162         return self._get_entropy(value) >= 50
163
164
165 class ValidEmail(ValidValue):
166     def validate(self, value: str) -> bool:
167         try:
168             validate_email(value)
169         except ValidationError:
170             return False
171         else:
172             self.value = value
173             return True
174
175
176 class ValidPhone(ValidValue):
177     def validate(self, value: str) -> bool:
178         if not value.startswith("+") and value[1:].isnumeric() and len(value[1:]) < 16:
179             return False
180
181         self.value = value
182         return True
183
184
185 class ValidTime(ValidValue):
186     def validate(self, value: str) -> bool:
187         split_values = value.split(":")
188
189         if not len(split_values) == 3:
190             if len(split_values) == 2:
191                 self.value = datetime.time(*[int(i) for i in [*split_values, "00"]])  # type: ignore
192                 return True
193             return False
194
195         if False in [i.isnumeric() for i in split_values]:
196             return False
197
198         self.value = datetime.time(*[int(i) for i in split_values])  # type: ignore
199         return True
200
201
202 class ValidDate(ValidValue):
203     def validate(self, value: str) -> bool:
204         parts = value.split("/")
205         if len(parts) != 3:
206             return False
207
208         self.value = value
209         return (
210             ValidInteger().validate(parts[0])
211             and ValidInteger().validate(parts[1])
212             and ValidInteger().validate(parts[2])
213         )
214
215
216 class ValidJson(ValidValue):
217     def __init__(self, schema: dict[str, ValidValue], is_optional = False, arbitrary = False):
218         self.schema = schema
219         self.keys = list(schema.keys())
220         self.arbitrary = arbitrary
221         super().__init__(is_optional)
222
223     def validate(self, value: str) -> bool:
224         try:
225             if type(value) is str:
226                 self.value = json.loads(value)
227             else:
228                 self.value = value
229             if self.arbitrary:
230                 return True
231             for key, value in cast(dict, self.value).items():
232                 if key not in self.keys:
233                     return False
234                 if not self.schema[key].validate(value):
235                     return False
236         except Exception as e:
237             print(e)
238             return False
239         return True
240
241
242 class ValidBoolean(ValidValue):
243     def validate(self, value: str) -> bool:
244         if type(value) is bool:
245             self.value = value
246             return True
247         if value.lower() == "true":
248             self.value = True
249             return True
250         if value.lower() == "false":
251             self.value = False
252             return True
253         return False
254
255
256 class ValidMealTime(ValidValue):
257     def validate(self, value: str) -> bool:
258         self.value = value or 0
259         return self.value in [0, 1, 2, 3]
260
261 class ValidList(ValidValue):
262     def validate(self, value: str) -> bool:
263         try:
264             self.value = [int(i) for i in value.split(",") if i]
265         except:
266             return False
267         return True


В.7 Код, який слугує проміжним програмним забезпеченням, що полегшує написання кінцевих точок view.py.
1 from typing import Callable
2
3 from django.http import HttpResponse
4
5 from api.models import User
6 from django.urls import path
7 from rest_framework.decorators import api_view
8 from rest_framework.response import Response
9
10 from .lang import Lang
11
12
13 def transform_name(name: str):
14     if name.startswith("post_"):
15         return "POST", name[5:]
16     if name.startswith("delete_"):
17         return "DELETE", name[7:]
18     if name.startswith("get_"):
19         return "GET", name[4:]
20     return "GET", name
21
22
23 def is_token_valid(token: str):
24     return len(token.split(":")) == 2
25
26
27 class GenClass:
28     @classmethod
29     def _get_locals(cls):
30         return {
31             k: v
32             for k, v in cls.__dict__.items()
33             if not k.startswith("__") and k[0].lower() == k[0]
34         }.items()
35
36
37 class Args(GenClass):
38     def __init__(self, lang: Lang):
39         self.is_cancelled = False
40         self.error = {}
41         self.lang = lang
42
43     def as_dict(self, filters: list[str] = []):
44         if not filters:
45             filters = []
46
47         return {
48             k: v
49             for k, v in self.__dict__.items()
50             if not k.startswith("__")
51             and k not in ["is_cancelled", "error", "lang", *filters]
52         }
53
54     def add_error(self, key: str, message: str, *args):
55         self.is_cancelled = True
56         if "." in key:
57             first, second = key.split(".")
58             if not self.error.get(first):
59                 self.error[first] = {}
60             self.error[first][second] = self.lang.translate(message, *args)
61         else:
62             self.error[key] = self.lang.translate(message, *args)
63
64     def validate_all(self, data: dict):
65         for name, validator in self.__class__._get_locals():
66             if type(validator) is dict:
67                 updated = {}
68                 for n, v in validator.items():
69                     updated[n] = v.get_valid_value(
70                         self.add_error, data.get(name, {}), n, parent=name
71                     )
72                 setattr(self, name, updated)
73             else:
74                 setattr(
75                     self, name, validator.get_valid_value(self.add_error, data, name)
76                 )
77         return self
78
79
80 class View(GenClass):
81     def __init__(self, name: str, request, lang: str):
82         self.name = name
83         self.request = request
84         self._body = request.data
85         self.lang = Lang(lang)
86
87     @classmethod
88     def _get_path(cls, fn: Callable, method: str, name: str):
89         params = []
90         if (
91             type(fn).__name__ in ["function"]
92             and "query_id" in fn.__annotations__.keys()
93         ):
94             params.append(f"@<{fn.__annotations__['query_id'].__name__}:query_id>")
95         return path(
96             "/".join([cls.__name__.lower().replace("view", ""), name, *params]),
97             api_view([method])(
98                 lambda request, lang, *args, **kwargs: cls(
99                     name, request, lang
100                 )._respond(method.lower(), *args, **kwargs)
101             ),
102             name=name,
103         )
104
105     @classmethod
106     def get_url_patterns(cls):
107         return [
108             cls._get_path(fn, *transform_name(name)) for name, fn in cls._get_locals()
109         ]
110
111     def _respond(self, method: str, *args, **kwargs):
112         fn: Callable = getattr(self, "_".join([method, self.name]))
113
114         # Authenticate
115         if fn.__annotations__.get("user"):
116             token = self.request.headers.get("Authorization")
117             if not token or not is_token_valid(token):
118                 return Response(
119                     {"error": self.lang.translate("user.not_authenticated")},
120                     status=401,
121                     headers={"Access-Control-Allow-Origin": "*"},
122                 )
123             user_id, password = token.split(":")
124             user = User.secure_get(user_id=user_id[1:], password=password)
125             if not user:
126                 return Response(
127                     {"error": self.lang.translate("user.not_authenticated")},
128                     status=401,
129                     headers={"Access-Control-Allow-Origin": "*"},
130                 )
131             args = [user, *args]
132
133         if method == "post":
134             view_args: Args = fn.__annotations__["post"](self.lang)
135             if view_args.validate_all(self._body).is_cancelled:
136                 code, response = 400, {"error": view_args.error}
137             else:
138                 code, response = fn(view_args, *args, **kwargs)
139         else:
140             code, response = fn(*args, **kwargs)
141         if code == 201:
142             return HttpResponse(response, headers={"Access-Control-Allow-Origin": "*"})  # type: ignore
143         return Response(
144             response, status=code, headers={"Access-Control-Allow-Origin": "*"}
145         )
ДОДАТОК В
Програмний код IoT пристрою

Головний файл «main.c»:
1 #include <curl/curl.h>
2 #include <json-c/json.h>
3 #include <stdio.h>
4 #include <stdlib.h>
5 #include <string.h>
6 #include <time.h>
7 #include <unistd.h>
8
9 #define CONFIG_FILE "config.json"
10
11 typedef struct {
12   char protocol[5];
13   char ip[256];
14   int port;
15   char user_id[16];
16 } Config;
17
18 void read_config(Config *config) {
19   FILE *file = fopen(CONFIG_FILE, "r");
20   if (!file) {
21     fprintf(stderr, "Could not open config file.\n");
22     exit(1);
23   }
24
25   struct json_object *parsed_json;
26   struct json_object *ip;
27   struct json_object *port;
28   struct json_object *user_id;
29   struct json_object *protocol;
30
31   char buffer[1024];
32   fread(buffer, 1024, 1, file);
33   fclose(file);
34
35   parsed_json = json_tokener_parse(buffer);
36   json_object_object_get_ex(parsed_json, "ip", &ip);
37   json_object_object_get_ex(parsed_json, "port", &port);
38   json_object_object_get_ex(parsed_json, "user_id", &user_id);
39   json_object_object_get_ex(parsed_json, "protocol", &protocol);
40
41   strcpy(config->ip, json_object_get_string(ip));
42   config->port = json_object_get_int(port);
43   strcpy(config->user_id, json_object_get_string(user_id));
44   strcpy(config->protocol, json_object_get_string(protocol));
45
46   json_object_put(parsed_json);
47 }
48
49 // FIXME: Цю функцію потрібно прибрати коли сенсори будуть підключені.
50 int get_random_value(int from, int to) { return rand() % (to - from) + from; }
51
52 // Ця функція зараз генерує рандомні значення, у майбутньому вони будуть
53 // отримані із сенсорів.
54 void read_sensor_values(char *data, char *user_id) {
55   int blood_pressure = get_random_value(80, 120);
56   int heart_rate = get_random_value(60, 100);
57   int oxygen_level = get_random_value(90, 100);
58
59   sprintf(data,
60           "{\"user_id\": \"%s\", \"blood_pressure\": %d, \"heart_rate\": %d, "
61           "\"oxygen_level\": %d}",
62           user_id, blood_pressure, heart_rate, oxygen_level);
63 }
64
65 size_t post_callback(void *ptr, size_t size, size_t nmemb, void *userdata) {
66   size_t realsize = size * nmemb;
67   FILE *out = fopen("received_data.json", "w");
68   if (out) {
69     fwrite(ptr, size, nmemb, out);
70     fclose(out);
71   }
72   return realsize;
73 }
74
75 void send_post_request(const Config *config, const char *data) {
76   CURL *curl;
77   CURLcode res;
78
79   curl_global_init(CURL_GLOBAL_DEFAULT);
80   curl = curl_easy_init();
81   if (curl) {
82     char url[512];
83     struct curl_httppost post;
84     snprintf(url, sizeof(url), "%s://%s:%d/api/en/iot/update", config->protocol,
85              config->ip, config->port);
86
87     curl_easy_setopt(curl, CURLOPT_URL, url);
88     curl_easy_setopt(curl, CURLOPT_HTTPHEADER,
89                      curl_slist_append(NULL, "Content-Type: application/json"));
90     curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "POST");
91     curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);
92
93     res = curl_easy_perform(curl);
94     if (res != CURLE_OK) {
95       fprintf(stderr, "curl_easy_perform() failed: %s\n",
96               curl_easy_strerror(res));
97     }
98
99     curl_easy_cleanup(curl);
100   }
101
102   curl_global_cleanup();
103 }
104
105 void send_get_request(const Config *config) {
106   CURL *curl;
107   CURLcode res;
108
109   curl_global_init(CURL_GLOBAL_DEFAULT);
110   curl = curl_easy_init();
111   if (curl) {
112     char url[512];
113     snprintf(url, sizeof(url), "%s://%s:%d/api/en/account/query/@%s",
114              config->protocol, config->ip, config->port, config->user_id);
115
116     curl_easy_setopt(curl, CURLOPT_URL, url);
117     curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, post_callback);
118
119     res = curl_easy_perform(curl);
120     if (res != CURLE_OK) {
121       fprintf(stderr, "curl_easy_perform() failed: %s\n",
122               curl_easy_strerror(res));
123     }
124
125     curl_easy_cleanup(curl);
126   }
127   curl_global_cleanup();
128 }
129
130 int main() {
131   Config config;
132   read_config(&config);
133
134   srand(time(NULL));
135
136   while (1) {
137     char sensor_data[256];
138     read_sensor_values(sensor_data, config.user_id);
139
140     send_post_request(&config, sensor_data);
141
142     send_get_request(&config);
143
144     FILE *file = fopen("received_data.json", "r");
145     if (file) {
146       char buffer[1024];
147       fread(buffer, sizeof(buffer), 1, file);
148       fclose(file);
149       printf("\n\nReceived Data: %s\n", buffer);
150     } else {
151       fprintf(stderr, "Could not open received data file.\n");
152     }
153
154     sleep(1);
155   }
156
157   return 0;
158 }

Файл конфігурації «config.json»:
1 {
2   "protocol": "http",
3   "ip": "127.0.0.1",
4   "port": 8000,
5   "user_id": "root"
6 }
ДОДАТОК Г
Програмний код клієнтської частини


Головний файл «+page.svelte»:
1 <script lang="ts">
2       import { extractToken, GET, type User } from "$lib"
3       import Header from "$lib/components/Header.svelte"
4       import { browser } from "$app/environment"
5       import { translate } from "$lib/i18n"
6
7       export let data: any
8
9       let user: User
10      if (data.token) {
11              GET(`/account/query/@${extractToken(data.token).username}`).then(
12                      (response) => {
13                              if (response.code != 200) {
14                                      console.log(response.body)
15                                      alert("Error fetching data!")
16                                      return
17                              }
18                              user = response.body
19                      }
20              )
21      }
22 </script>
23
24 <Header {data} />
25 {#if user}
26      <main class="dark:text-white text-center">
27              <h1 class="font-bold mb-5 text-2xl">
28                      {$translate("welcome", { f: user.first_name, l: user.last_name })}
29              </h1>
30
31              <fieldset class="mb-5">
32                      <legend class="font-bold">{$translate("field.weight")}</legend>
33                      <span>{user.weight || $translate("unknown")}</span>
34              </fieldset>
35              <fieldset class="mb-5">
36                      <legend class="font-bold">{$translate("field.fat")}</legend>
37                      <span>{user.body_fat || $translate("unknown")}</span>
38              </fieldset>
39              <fieldset class="mb-5">
40                      <legend class="font-bold">{$translate("field.heart")}</legend>
41                      <span>{user.heart_rate || $translate("unknown")}</span>
42              </fieldset>
43              <fieldset class="mb-5">
44                      <legend class="font-bold">{$translate("field.oxygen")}</legend>
45                      <span>{user.oxygen_level || $translate("unknown")}</span>
46              </fieldset>
47              <fieldset class="mb-5">
48                      <legend class="font-bold">{$translate("field.blood")}</legend>
49                      <span>{user.blood_pressure || $translate("unknown")}</span>
50              </fieldset>
51      </main>
52 {/if}

Файл панелі адміністратора «+page.svelte»:
1 <script lang="ts">
2       import Header from "$lib/components/Header.svelte"
3       import { Card, Label, Input, Button, Select } from "flowbite-svelte"
4       import { GET, POST, extractToken, project, type User } from "$lib"
5       import { translate } from "$lib/i18n"
6
7       export let data: any
8
9       let user: User
10      if (data.token) {
11              GET(`/account/query/@${extractToken(data.token).username}`).then(
12                      (response) => {
13                              if (response.code != 200) {
14                                      console.log(response.body)
15                                      alert("Error fetching data!")
16                                      return
17                              }
18                              user = response.body
19                      }
20              )
21      }
22 </script>
23
24 <Header {data} />
25 <main class="dark:text-white">
26      <h1>{$translate("admin.backups")}:</h1>
27      <div>
28              <select id="backup" class="text-black">
29                      <option value="users" selected>{$translate("admin.users")}</option>
30                      <option value="profiles">{$translate("admin.profiles")}</option>
31                      <option value="diets">{$translate("header.diets")}</option>
32                      <option value="meal_plans">{$translate("header.meal_plans")}</option
33                      >
34                      <option value="submissions"
35                              >{$translate("admin.submissions")}</option
36                      >
37                      <option value="foods">{$translate("header.foods")}</option>
38                      <option value="nutritions">{$translate("admin.nutritions")}</option>
39              </select>
40              <Button
41                      on:click={() => {
42                              // @ts-ignore
43                              const val = document.getElementById("backup").value
44                              GET(
45                                      `/system/backup/@${val}`,
46                                      "GET",
47                                      {
48                                              Authorization: data.token,
49                                      },
50                                      false
51                              ).then((response) => {
52                                      if (response.code != 200) {
53                                              console.log(response.body)
54                                              alert("Error fetching data!")
55                                              return
56                                      }
57                                      const popup = window.open()
58                                      if (popup) {
59                                              popup.document.write(
60                                                      response.body.split("\n").join("<br/>")
61                                              )
62                                              popup.document.title = `${val}.csv`
63                                      }
64                              })
65                      }}>{$translate("create")}</Button
66              >
67      </div>
68      <h1>{$translate("admin.rollback")}:</h1>
69      <div>
70              <select id="rollback" class="text-black">
71                      <option value="users" selected>{$translate("admin.users")}</option>
72                      <option value="profiles">{$translate("admin.profiles")}</option>
73                      <option value="diets">{$translate("header.diets")}</option>
74                      <option value="meal_plans">{$translate("header.meal_plans")}</option
75                      >
76                      <option value="submissions"
77                              >{$translate("admin.submissions")}</option
78                      >
79                      <option value="foods">{$translate("header.foods")}</option>
80                      <option value="nutritions">{$translate("admin.nutritions")}</option>
81              </select>
82              <Button
83                      on:click={() => {
84                              // @ts-ignore
85                              const val = document.getElementById("rollback").value
86                              POST(
87                                      `/system/rollback`,
88                                      {
89                                              resource: val,
90                                              // @ts-ignore
91                                              data: document.getElementById("rollback_data").value,
92                                      },
93                                      [`Authorization->${data.token}`],
94                                      false
95                              ).then((response) => {
96                                      if (response.code != 200) {
97                                              console.log(response.body)
98                                              alert("Error fetching data!")
99                                              return
100                                     }
101                                     window.location.href = window.location.origin
102                             })
103                     }}>{$translate("submit")}</Button
104             >
105     </div>
106     <textarea
107             id="rollback_data"
108             placeholder="file.csv"
109             class="text-black w-full"
110     ></textarea>
111 </main>

Файл дієт «+page.svelte»:
1 <script lang="ts">
2       import Header from "$lib/components/Header.svelte"
3       import { Button, Card } from "flowbite-svelte"
4       import {
5               GET,
6               ITEMS_PER_PAGE,
7               extractToken,
8               type Diet,
9               type User,
10      } from "$lib"
11      import { translate } from "$lib/i18n"
12
13      export let data: any
14
15      let user: User
16      GET(`/account/query/@${extractToken(data.token).username}`).then(
17              (response) => {
18                      if (response.code != 200) {
19                              console.log(response.body)
20                              alert("Error fetching data!")
21                              return
22                      }
23                      user = response.body
24              }
25      )
26
27      let page = 0
28      let maxPages = 1
29      let diets: Diet[] = []
30      function update() {
31              GET(`/diet/all/@${page}:${ITEMS_PER_PAGE}`).then((response) => {
32                      if (response.code != 200) {
33                              console.log(response.body)
34                              alert("Error fetching data!")
35                              return
36                      }
37                      maxPages = Math.round(response.body.overflow / ITEMS_PER_PAGE) + 1
38                      if (maxPages <= page) {
39                              page = maxPages - 1
40                      }
41                      diets = response.body.results
42              })
43      }
44      update()
45 </script>
46
47 <Header {data} />
48 <main class="dark:text-white flex-col justify-stretch w-fit m-auto gap-5">
49      <h1 class="mb-5 text-2xl font-bold dark:text-white">
50              {$translate("diet")}
51      </h1>
52      {#each diets as diet}
53              <Card>
54                      <img src={diet.photo_url} alt={diet.photo_url} />
55                      <h5>{diet.name}</h5>
56                      {diet.description}
57                      <h5>Average intake:</h5>
58                      <span>{$translate("fat", { v: diet.average_intake.fat })}</span>
59                      <span>{$translate("carbs", { v: diet.average_intake.carbs })}</span>
60                      <span
61                              >{$translate("protein", {
62                                      v: diet.average_intake.protein,
63                              })}</span
64                      >
65                      <span
66                              >{$translate("calories", {
67                                      v: diet.average_intake.calories,
68                              })}</span
69                      >
70                      <span
71                              >{$translate("amino_acids", {
72                                      v: JSON.stringify(diet.average_intake.amino_acids),
73                              })}</span
74                      >
75                      <span
76                              >{$translate("minerals", {
77                                      v: JSON.stringify(diet.average_intake.minerals),
78                              })}</span
79                      >
80                      <span
81                              >{$translate("vitamins", {
82                                      v: JSON.stringify(diet.average_intake.vitamins),
83                              })}</span
84                      >
85                      <Button outline={true} href="/diets/@{diet.diet_id}"
86                              >{$translate("more")}</Button
87                      >
88              </Card>
89      {/each}
90      {#if user?.role.id > 0}
91              <Button style="width: 100%;" href="/diets/new"
92                      >{$translate("new")}</Button
93              >
94      {/if}
95 </main>

Файл їж «+page.svelte»:
1 <script lang="ts">
2       import Header from "$lib/components/Header.svelte"
3       import { Button, Card } from "flowbite-svelte"
4       import {
5               GET,
6               ITEMS_PER_PAGE,
7               extractToken,
8               type Food,
9               type User,
10      } from "$lib"
11      import { translate } from "$lib/i18n"
12
13      export let data: any
14
15      let user: User
16      GET(`/account/query/@${extractToken(data.token).username}`).then(
17              (response) => {
18                      if (response.code != 200) {
19                              console.log(response.body)
20                              alert("Error fetching data!")
21                              return
22                      }
23                      user = response.body
24              }
25      )
26
27      let page = 0
28      let maxPages = 1
29      let foods: Food[] = []
30      function update() {
31              GET(`/food/all/@${page}:${ITEMS_PER_PAGE}`).then((response) => {
32                      if (response.code != 200) {
33                              console.log(response.body)
34                              alert("Error fetching data!")
35                              return
36                      }
37                      maxPages = Math.round(response.body.overflow / ITEMS_PER_PAGE) + 1
38                      if (maxPages <= page) {
39                              page = maxPages - 1
40                      }
41                      foods = response.body.results
42              })
43      }
44      update()
45 </script>
46
47 <Header {data} />
48 <main class="dark:text-white flex-col justify-stretch w-fit m-auto gap-5">
49      <h1 class="mb-5 text-2xl font-bold dark:text-white">
50              {$translate("food")}
51      </h1>
52      {#each foods as food}
53              <Card>
54                      <img src={food.photo_url} alt={food.photo_url} />
55                      <h1 class="mb-5 text-2xl font-bold dark:text-white">{food.name}</h1>
56                      <span>{food.description}</span>
57                      <div>
58                              <strong>{$translate("fat", { v: food.fat })}</strong>
59                              <strong>{$translate("carbs", { v: food.carbs })}</strong>
60                              <strong>{$translate("protein", { v: food.protein })}</strong>
61                      </div>
62                      <Button outline={true} href="/foods/@{food.food_id}"
63                              >{$translate("more")}</Button
64                      >
65              </Card>
66      {/each}
67      {#if user?.role.id > 0}
68              <Button style="width: 100%;" href="/foods/new"
69                      >{$translate("new")}</Button
70              >
71      {/if}
72 </main>

Файл сторінки входу в систему «+page.svelte»:
1 <script lang="ts">
2       import Header from "$lib/components/Header.svelte"
3       import { Card, Label, Input, Button } from "flowbite-svelte"
4       import { UserOutline } from "flowbite-svelte-icons"
5       import { POST, setCookie } from "$lib"
6       import { translate } from "$lib/i18n"
7
8       export let data: any
9       let errors: string[] = []
10 </script>
11
12 <Header {data} />
13 <main class="dark:text-white">
14      <Card>
15              <h1 class="mb-5 text-2xl font-bold dark:text-white">
16                      {$translate("login")}
17              </h1>
18              <div class="mb-5">
19                      <Label class="block mb-2">{$translate("username")}</Label>
20                      <Input id="user_id" required placeholder="@user_id" />
21              </div>
22              <div class="mb-5">
23                      <Label class="block mb-2">{$translate("password")}</Label>
24                      <Input
25                              id="password"
26                              required
27                              type="password"
28                              placeholder="••••••"
29                      />
30              </div>
31              <a class="mb-5" href="/register">{$translate("no_account")}</a>
32              {#each errors as error}
33                      <span class="text-red-500 mb-5">{error}</span>
34              {/each}
35              <Button
36                      class="w-fit"
37                      on:click={async () => {
38                              errors = []
39
40                              let post_data = {}
41                              const post_fields = ["user_id", "password"]
42                              post_fields.forEach((name) => {
43                                      // @ts-ignore
44                                      post_data[name] = document.getElementById(name)?.value
45                              })
46
47                              let response = await POST("/account/login", post_data)
48                              if (response.code != 200) {
49                                      if (typeof response.body.error == "string") {
50                                              errors = [...errors, response.body.error]
51                                              return
52                                      }
53                                      for (const key in response.body.error) {
54                                              if (response.body.error.hasOwnProperty(key)) {
55                                                      const value = response.body.error[key]
56                                                      errors.push(
57                                                              // @ts-ignore
58                                                              `${value} ("${document.getElementById(key)?.value}")`
59                                                      )
60                                                      errors = [...errors]
61                                              }
62                                      }
63                                      return
64                              }
65
66                              document.cookie = setCookie("token", response.body.token, 60)
67                              window.location.href = window.location.origin
68                      }}
69              >
70                      {$translate("login")}
71                      <UserOutline class="w-6 h-6 ms-2 text-white" />
72              </Button>
73      </Card>
74 </main>

Файл планів харчування «+page.svelte»:
1 <script lang="ts">
2       import Header from "$lib/components/Header.svelte"
3       import { Button, Card } from "flowbite-svelte"
4       import {
5               GET,
6               ITEMS_PER_PAGE,
7               extractToken,
8               type Diet,
9               type MealPlan,
10              type User,
11      } from "$lib"
12      import { translate } from "$lib/i18n"
13
14      export let data: any
15
16      let user: User
17      GET(`/account/query/@${extractToken(data.token).username}`).then(
18              (response) => {
19                      if (response.code != 200) {
20                              console.log(response.body)
21                              alert("Error fetching data!")
22                              return
23                      }
24                      user = response.body
25              }
26      )
27
28      let page = 0
29      let maxPages = 1
30      let meal_plans: MealPlan[] = []
31      function update() {
32              GET(`/mealplan/all/@${page}:${ITEMS_PER_PAGE}`).then((response) => {
33                      if (response.code != 200) {
34                              console.log(response.body)
35                              alert("Error fetching data!")
36                              return
37                      }
38                      maxPages = Math.round(response.body.overflow / ITEMS_PER_PAGE) + 1
39                      if (maxPages <= page) {
40                              page = maxPages - 1
41                      }
42                      meal_plans = response.body.results
43              })
44      }
45      update()
46 </script>
47
48 <Header {data} />
49 <main class="dark:text-white flex-col justify-stretch w-fit m-auto gap-5">
50      <h1 class="mb-5 text-2xl font-bold dark:text-white">
51              {$translate("meal_plan")}
52      </h1>
53      {#each meal_plans as meal_plan}
54              <Card>
55                      <img
56                              src={meal_plan.diet.photo_url}
57                              alt={meal_plan.diet.photo_url}
58                      />
59                      {meal_plan.diet.name}
60                      <Button outline={true} href="/meal_plans/@{meal_plan.meal_plan_id}"
61                              >{$translate("more")}</Button
62                      >
63              </Card>
64      {/each}
65      {#if user?.role.id > 0}
66              <Button style="width: 100%;" href="/meal_plans/new"
67                      >{$translate("new")}</Button
68              >
69      {/if}
70 </main>

Файл створення аккаунту «+page.svelte»:
1 <script lang="ts">
2       import Header from "$lib/components/Header.svelte"
3       import { Card, Label, Input, Button } from "flowbite-svelte"
4       import { UserOutline } from "flowbite-svelte-icons"
5       import { GET, POST, setCookie } from "$lib"
6       import { translate } from "$lib/i18n"
7
8       export let data: any
9       let errors: string[] = []
10
11      const validateEmail = (email: string) => {
12              return String(email)
13                      .toLowerCase()
14                      .match(
15                              /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|.(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
16                      )
17      }
18 </script>
19
20 <Header {data} />
21 <main class="dark:text-white">
22      <Card>
23              <h1 class="mb-5 text-2xl font-bold dark:text-white">Register</h1>
24              <div class="mb-5">
25                      <Label class="block mb-2">{$translate("username")}</Label>
26                      <Input
27                              id="user_id"
28                              required
29                              placeholder="@user_id"
30                              maxlength="16"
31                      />
32              </div>
33              <div class="mb-5">
34                      <Label class="block mb-2">{$translate("first_name")}</Label>
35                      <Input id="first_name" required placeholder="" />
36              </div>
37              <div class="mb-5">
38                      <Label class="block mb-2">{$translate("last_name")}</Label>
39                      <Input id="last_name" required placeholder="" />
40              </div>
41              <div class="mb-5">
42                      <Label class="block mb-2">{$translate("email")}</Label>
43                      <Input
44                              id="email"
45                              type="email"
46                              required
47                              placeholder="me@example.com"
48                      />
49              </div>
50              <div class="mb-5">
51                      <Label class="block mb-2">{$translate("password")}</Label>
52                      <Input
53                              id="password"
54                              required
55                              type="password"
56                              placeholder="••••••"
57                      />
58              </div>
59              <div class="mb-5">
60                      <Label class="block mb-2">{$translate("birth")}</Label>
61                      <Input id="date_of_birth" type="date" required placeholder="" />
62              </div>
63              <a class="mb-5" href="/login">{$translate("yes_account")}</a>
64              {#each errors as error}
65                      <span class="text-red-500 mb-5">{error}</span>
66              {/each}
67              <Button
68                      class="w-fit"
69                      on:click={async () => {
70                              errors = []
71
72                              let post_data = {}
73                              const post_fields = [
74                                      "user_id",
75                                      "first_name",
76                                      "last_name",
77                                      "email",
78                                      "password",
79                                      "date_of_birth",
80                              ]
81                              post_fields.forEach((name) => {
82                                      // @ts-ignore
83                                      post_data[name] = document.getElementById(name)?.value
84                              })
85
86                              let response = await POST("/account/register", post_data)
87                              if (response.code != 200) {
88                                      if (typeof response.body.error == "string") {
89                                              errors = [...errors, response.body.error]
90                                              return
91                                      }
92                                      for (const key in response.body.error) {
93                                              if (response.body.error.hasOwnProperty(key)) {
94                                                      const value = response.body.error[key]
95                                                      errors.push(
96                                                              // @ts-ignore
97                                                              `${value} ("${document.getElementById(key)?.value}")`
98                                                      )
99                                                      errors = [...errors]
100                                             }
101                                     }
102                                     return
103                             }
104
105                             document.cookie = setCookie("token", response.body.token, 60)
106                             window.location.href = window.location.origin
107                     }}
108             >
109                     {$translate("register")}
110                     <UserOutline class="w-6 h-6 ms-2 text-white" />
111             </Button>
112     </Card>
113 </main>

Файл налаштувань «+page.svelte»:
1 <script lang="ts">
2       import Header from "$lib/components/Header.svelte"
3       import { Card, Label, Input, Button, Select } from "flowbite-svelte"
4       import { UserOutline } from "flowbite-svelte-icons"
5       import { POST, setCookie, project, globalAPI, globalLocale } from "$lib"
6       import { translate } from "$lib/i18n"
7
8       export let data: any
9       let errors: string[] = []
10
11      let selected: string = project.LOCALE
12      let locales = [
13              { value: "en", name: "English (US)" },
14              { value: "ua", name: "Українська" },
15      ]
16 </script>
17
18 <Header {data} />
19 <main class="dark:text-white">
20      <Card>
21              <h1 class="mb-5 text-2xl font-bold dark:text-white">
22                      {$translate("settings")}
23              </h1>
24              <div class="mb-5">
25                      <Label class="block mb-2">{$translate("api")}</Label>
26                      <Input id="api" required value={project.API} />
27              </div>
28              <div class="mb-5">
29                      <Label class="block mb-2">{$translate("locale")}</Label>
30                      <Select id="locale" items={locales} bind:value={selected} />
31              </div>
32              <Button
33                      class="w-fit"
34                      on:click={async () => {
35                              // @ts-ignore
36                              globalAPI.set(document.getElementById("api")?.value)
37                              // @ts-ignore
38                              globalLocale.set(document.getElementById("locale")?.value)
39                      }}
40              >
41                      {$translate("save")}
42              </Button>
43      </Card>
44 </main>

Файл сторінки користувача «+page.svelte»:
1 <script lang="ts">
2       import { GET, type User } from "$lib"
3       import Header from "$lib/components/Header.svelte"
4       import { translate } from "$lib/i18n"
5       import { Card } from "flowbite-svelte"
6
7       export let data: any
8
9       let user: User | null = null
10      GET(`/account/query/@${data.user_id}`).then((response) => {
11              if (response.code != 200) {
12                      alert(JSON.stringify(response.body))
13                      return
14              }
15
16              user = response.body
17      })
18 </script>
19
20 <Header {data} />
21 <main class="dark:text-white">
22      <Card style="max-width: 32rem;">
23              <h5 class="text-2xl font-bold tracking-tight dark:text-white">
24                      {user?.first_name}
25                      {user?.last_name}
26              </h5>
27              <span class="mb-2">@{user?.user_id}</span>
28              <div class="flex items-baseline gap-2 dark:text-white">
29                      <span class="text-1xl font-semibold">{$translate("email")}</span>
30                      <span class="text-1xl font-normal">{user?.email}</span>
31              </div>
32              <div class="flex items-baseline gap-2 dark:text-white">
33                      <span class="text-1xl font-semibold">{$translate("birth")}</span>
34                      <span class="text-1xl font-normal"
35                              >{new Date(user?.date_of_birth || "").toLocaleString()}</span
36                      >
37              </div>
38      </Card>
39 </main>

Файл бібліотеки для перекладу «i18n.ts»:
1 import { derived, writable } from "svelte/store"
2 import translations from "./translations"
3 import { globalLocale } from "$lib"
4
5 export const locales = Object.keys(translations)
6
7 function get_translations(locale: string, key: string, vars: any) {
8       // Let's throw some errors if we're trying to use keys/locales that don't exist.
9       // We could improve this by using Typescript and/or fallback values.
10      if (!key) return "~~"
11      if (!locale) return "~~"
12
13      // Grab the translation from the translations object.
14      // @ts-ignore
15      let text = translations[locale][key]
16
17      if (!text) return `~${key}~`
18
19      // Replace any passed in variables in the translation string.
20      Object.keys(vars).map((k) => {
21              const regex = new RegExp(`{{${k}}}`, "g")
22              text = text.replace(regex, vars[k])
23              console.log(text)
24      })
25
26      return text
27 }
28
29 export const translate = derived(
30      globalLocale,
31      ($locale) =>
32              (key: string, vars = {}) =>
33                      get_translations($locale, key, vars)
34 )


Допоміжний файл «index.ts»:
1 import { writable } from "svelte/store"
2
3 export const globalAPI = writable("http://127.0.0.1:8000")
4 export const globalLocale = writable("en")
5
6 export const ITEMS_PER_PAGE = 16
7
8 export interface Global {
9       API: string
10      LOCALE: string
11 }
12
13 export const project: Global = {
14      API: "http://127.0.0.1:8000",
15      LOCALE: "en",
16 }
17
18 globalAPI.subscribe((value) => {
19      project.API = value
20 })
21
22 globalLocale.subscribe((value) => {
23      project.LOCALE = value
24 })
25
26 export function setCookie(cname: string, cvalue: string, exdays: number) {
27      const d = new Date()
28      d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000)
29      let expires = "expires=" + d.toUTCString()
30      return cname + "=" + cvalue + ";" + expires + ";path=/"
31 }
32
33 export function deleteCookie(cname: string) {
34      return cname + "=;expires=Thu, 01 Jan 1970 00:00:01 GMT;"
35 }
36
37 interface token {
38      username: string
39      password: string
40 }
41
42 export function extractToken(token: string): token {
43      if (token == undefined) {
44              return {
45                      username: "Unknown",
46                      password: "none",
47              }
48      }
49      return {
50              username: token.split(":")[0].split("@")[1],
51              password: token.split(":")[1],
52      }
53 }
54
55 interface response {
56      code: number
57      body: any
58 }
59
60 export async function GET(
61      endpoint: string,
62      method: string = "GET",
63      headers: any = {},
64      use_json: boolean = true
65 ): Promise<response> {
66      try {
67              const response = await fetch(
68                      `${project.API}/api/${project.LOCALE}${endpoint}`,
69                      {
70                              method: method,
71                              headers: headers,
72                      }
73              )
74              if (!response.ok) {
75                      throw new Error(`Failed to fetch: ${await response.json()}`)
76              }
77              if (use_json) {
78                      return {
79                              code: response.status,
80                              body: await response.json(),
81                      }
82              } else {
83                      return {
84                              code: response.status,
85                              body: await response.text(),
86                      }
87              }
88      } catch (err: any) {
89              console.log(err.message)
90      }
91
92      return { code: 0, body: null }
93 }
94
95 export async function DELETE(
96      endpoint: string,
97      headers: any
98 ): Promise<response> {
99      return GET(endpoint, "DELETE", headers)
100 }
101
102 export async function POST(
103     endpoint: string,
104     data: any,
105     headers: string[] = [],
106     is_json: boolean = true
107 ): Promise<response> {
108     try {
109             let head = {
110                     "Content-Type": "application/json",
111             }
112             headers.forEach((header) => {
113                     // @ts-ignore
114                     head[header.split("->")[0]] = header.split("->")[1]
115             })
116
117             const response = await fetch(
118                     `${project.API}/api/${project.LOCALE}${endpoint}`,
119                     {
120                             method: "POST",
121                             headers: head,
122                             body: JSON.stringify(data),
123                     }
124             )
125             if (!response.ok) {
126                     return {
127                             code: response.status,
128                             body: await response.json(),
129                     }
130             }
131             if (is_json) {
132                     return {
133                             code: response.status,
134                             body: await response.json(),
135                     }
136             } else {
137                     return {
138                             code: response.status,
139                             body: await response.text(),
140                     }
141             }
142     } catch (err: any) {
143             console.log(err.message)
144     }
145
146     return { code: 0, body: null }
147 }
148
149 export interface User {
150     user_id: string
151     email: string
152     first_name: string
153     last_name: string
154     weight?: number
155     body_fat?: number
156     heart_rate?: number
157     blood_pressure?: number
158     oxygen_level?: number
159     role: {
160             id: number
161             name: string
162     }
163     date_of_birth: string
164     created_at: string
165     updated_at: string
166     last_seen_at: string
167 }
168
169 export interface Food {
170     food_id: number
171     name: string
172     description: string
173     photo_url: string
174     carbs: number
175     protein: number
176     fat: number
177     calories: number
178     nutrition: {
179             nutrition_id: number
180             vitamins: any
181             minerals: any
182             amino_acids: any
183     }
184 }
185
186 export interface Diet {
187     diet_id: number
188     name: string
189     description: string
190     photo_url: string
191     average_intake: {
192             carbs: number
193             protein: number
194             fat: number
195             calories: number
196             vitamins: number
197             minerals: number
198             amino_acids: number
199     }
200 }
201
202 export interface MealPlan {
203     meal_plan_id: number
204     time: number
205     diet: Diet
206 }
207
208 export const VITAMINS = [
209     "vitamin_a",
210     "vitamin_b6",
211     "vitamin_b12",
212     "vitamin_c",
213     "vitamin_d",
214     "vitamin_e",
215     "vitamin_k1",
216     "betaine",
217     "choline",
218     "folate",
219     "thiamin",
220     "riboflavin",
221     "pantothenic_acid",
222     "niacin",
223 ]
224
225 export const MINERALS = [
226     "calcium",
227     "copper",
228     "fluoride",
229     "iron",
230     "magnesium",
231     "manganese",
232     "phosphorus",
233     "potassium",
234     "selenium",
235     "sodium",
236     "zinc",
237 ]
238
239 export const AMINO_ACIDS = [
240     "alanine",
241     "arginine",
242     "aspartic_acid",
243     "cystine",
244     "glutamic_acid",
245     "glycine",
246     "histidine",
247     "isoleucine",
248     "leucine",
249     "lysine",
250     "methionine",
251     "phenylalanine",
252     "proline",
253     "serine",
254     "threonine",
255     "tyrosine",
256     "valine",
257 ]

Файл перегладів «translations.ts»:
1 export default {
2       en: {
3               create: "Create",
4               submit: "Submit",
5               delete: "Delete",
6               edit: "Edit",
7               save: "Save",
8               description: "Description",
9               photo_url: "Photo URL",
10              name: "Name",
11              "header.home": "Home",
12              "header.meal_plans": "Meal Plans",
13              "header.diets": "Diets",
14              "header.foods": "Foods",
15              "header.admin": "Admin",
16              "header.my_profile": "My profile",
17              "header.settings": "Settings",
18              "header.sign_out": "Sign out",
19              "header.login": "Login",
20              "admin.backups": "Backups",
21              "admin.users": "Users",
22              "admin.profiles": "Profiles",
23              "admin.submissions": "Submissions",
24              "admin.nutritions": "Nutritions",
25              "admin.rollback": "Rollback",
26              "diet.edit": "Edit the diet",
27              "diet.new": "Create new diet",
28              diet: "Diets",
29              fat: "Fat: {{v}}",
30              carbs: "Carbs: {{v}}",
31              protein: "Protein: {{v}}",
32              calories: "Calories: {{v}}",
33              amino_acids: "Amino Acids: {{v}}",
34              minerals: "Minerals: {{v}}",
35              vitamins: "Vitamins: {{v}}",
36              more: "More",
37              new: "New",
38              "food.edit": "Edit the food",
39              "food.new": "Create new food",
40              food: "Foods",
41              login: "Login",
42              username: "Your username",
43              password: "Your password",
44              no_account: "Don't have an account?",
45              yes_account: "Already have an account?",
46              first_name: "First name",
47              last_name: "Last name",
48              email: "Your email",
49              birth: "Date of birth",
50              register: "Register",
51              settings: "Settings",
52              api: "API Server URL",
53              locale: "Locale",
54              welcome: "Welcome {{f}} {{l}}!",
55              "field.weight": "Weight",
56              "field.fat": "Body fat",
57              "field.heart": "Heart rate",
58              "field.oxygen": "Oxygen level",
59              "field.blood": "Blood pressure",
60              unknown: "(Unknown)",
61              "meal_plan.new": "Create new meal plan",
62              meal_plan: "Meal Plans",
63              breakfast: "Breakfast",
64              lunch: "Lunch",
65              snack: "Snack",
66              dinner: "Dinner",
67      },
68      ua: {
69              create: "Створити",
70              submit: "Надіслати",
71              delete: "Видалити",
72              edit: "Редагувати",
73              save: "Зберегти",
74              description: "Опис",
75              photo_url: "URL фотографії",
76              name: "Ім'я",
77              "header.home": "Головна",
78              "header.meal_plans": "Плани харчування",
79              "header.diets": "Дієти",
80              "header.foods": "Продукти",
81              "header.admin": "Адміністрування",
82              "header.my_profile": "Мій профіль",
83              "header.settings": "Налаштування",
84              "header.sign_out": "Вийти",
85              "header.login": "Увійти",
86              "admin.backups": "Резервні копії",
87              "admin.users": "Користувачі",
88              "admin.profiles": "Профілі",
89              "admin.submissions": "Відправлення",
90              "admin.nutritions": "Харчування",
91              "admin.rollback": "Відновлення",
92              "diet.edit": "Редагувати дієту",
93              "diet.new": "Створити нову дієту",
94              diet: "Дієти",
95              fat: "Жири: {{v}}",
96              carbs: "Вуглеводи: {{v}}",
97              protein: "Білки: {{v}}",
98              calories: "Калорії: {{v}}",
99              amino_acids: "Амінокислоти: {{v}}",
100             minerals: "Мінерали: {{v}}",
101             vitamins: "Вітаміни: {{v}}",
102             more: "Більше",
103             new: "Новий",
104             "food.edit": "Редагувати продукт",
105             "food.new": "Створити новий продукт",
106             food: "Продукти",
107             login: "Увійти",
108             username: "Ваше ім'я користувача",
109             password: "Ваш пароль",
110             no_account: "Немає облікового запису?",
111             yes_account: "Вже маєте обліковий запис?",
112             first_name: "Ім'я",
113             last_name: "Прізвище",
114             email: "Ваш email",
115             birth: "Дата народження",
116             register: "Зареєструватися",
117             settings: "Налаштування",
118             api: "URL сервера API",
119             locale: "Локаль",
120             welcome: "Ласкаво просимо, {{f}} {{l}}!",
121             "field.weight": "Вага",
122             "field.fat": "Жирова маса",
123             "field.heart": "Пульс",
124             "field.oxygen": "Рівень кисню",
125             "field.blood": "Тиск крові",
126             unknown: "(Невідомо)",
127             "meal_plan.new": "Створити новий план харчування",
128             meal_plan: "Плани харчування",
129             breakfast: "Сніданок",
130             lunch: "Обід",
131             snack: "Перекус",
132             dinner: "Вечеря",
133     },
134 }
